<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="/2021/11/13/JavaScript/"/>
    <url>/2021/11/13/JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript学习笔记"><a href="#JavaScript学习笔记" class="headerlink" title="JavaScript学习笔记"></a>JavaScript学习笔记</h1><h2 id="1-语法专题"><a href="#1-语法专题" class="headerlink" title="1. 语法专题"></a>1. 语法专题</h2><h3 id="1-1-数据类型的转换"><a href="#1-1-数据类型的转换" class="headerlink" title="1.1 数据类型的转换"></a>1.1 数据类型的转换</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = y ? <span class="hljs-number">1</span> : <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-强制转换"><a href="#2-强制转换" class="headerlink" title="2. 强制转换"></a>2. 强制转换</h4><h5 id="2-1-Number"><a href="#2-1-Number" class="headerlink" title="2.1 Number()"></a>2.1 Number()</h5><p>将任意类型的值转化成数值</p><p><strong>（1）原始类型值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">// 324</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;324&#x27;</span>) <span class="hljs-comment">// 324</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;324abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 空字符串转为0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多.基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;42 cats&#x27;</span>) <span class="hljs-comment">// 42</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;42 cats&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型。</p><p>另外，<code>parseInt</code>和<code>Number</code>函数都会自动过滤一个字符串前导和后缀的空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="hljs-comment">// 12.34</span><br></code></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p><code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>([<span class="hljs-number">5</span>]) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p><code>Number</code>背后的转换规则:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">Number</span>(obj) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj.valueOf() === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>  <span class="hljs-built_in">Number</span>(obj.toString());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">Number</span>(obj.valueOf());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-String"><a href="#2-2-String" class="headerlink" title="2.2 String()"></a>2.2 String()</h5><p><code>String</code>函数可以将<strong>任意类型的值</strong>转化成<strong>字符串</strong>，转换规则如下：</p><p><strong>（1）原始类型值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;null&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-built_in">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure><p><strong>转换规则</strong></p><ol><li>先调用<strong>对象自身的<code>toString</code><strong>方法。如果返回</strong>原始类型的值</strong>，则对该值使用<code>String</code>函数，不再进行以下步骤。</li><li>如果<code>toString</code>方法返回的是<strong>对象</strong>，再调用原对象的**<code>valueOf</code>方法**。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li><li>如果<code>valueOf</code>方法返回的是对象，就报错。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;.toString())<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><h5 id="2-3-Boolean"><a href="#2-3-Boolean" class="headerlink" title="2.3 Boolean()"></a>2.3 Boolean()</h5><p><code>Boolean()</code>函数可以将<strong>任意类型的值</strong>转为布尔值。</p><blockquote><p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p></blockquote><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li><li><code>NaN</code></li><li><code>&#39;&#39;</code>（空字符串）</li></ul><p>当然，<code>true</code>和<code>false</code>这两个布尔值不会发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连**<code>false</code>对应的布尔对象**<code>new Boolean(false)</code>也<strong>是<code>true</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>([]) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="3-自动转换（强制转换为基础）"><a href="#3-自动转换（强制转换为基础）" class="headerlink" title="3. 自动转换（强制转换为基础）"></a>3. 自动转换（强制转换为基础）</h4><p>自动转换的规则：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用<code>String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值。</p><p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>函数进行显式转换。</p><p><strong>3.1 自动转换为布尔值</strong></p><p>JavaScript 遇到预期为布尔值的地方（比如**<code>if</code>语句<strong>的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用</strong><code>Boolean()</code>函数**。</p><p><strong>3.2 自动转换为字符串</strong></p><p>JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值<strong>转为原始类型的值</strong>，再将原始类型的值转为字符串。</p><p><strong>3.3 自动转换为数值</strong></p><p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code>Number()</code>函数。</p><blockquote><p>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，<strong>其他运算符都会把运算子自动转成数值</strong>。</p></blockquote><blockquote><p>注意：**<code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>。**</p></blockquote><h3 id="1-2-错误处理机制"><a href="#1-2-错误处理机制" class="headerlink" title="1.2 错误处理机制"></a>1.2 错误处理机制</h3><h4 id="1-Error实例对象"><a href="#1-Error实例对象" class="headerlink" title="1. Error实例对象"></a>1. Error实例对象</h4><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个<strong>错误对象</strong>。JavaScript 原生<strong>提供<code>Error</code>构造函数</strong>，所有抛出的错误都是这个构造函数的<strong>实例</strong>。</p><p>Error的属性</p><ul><li><strong>message</strong>：错误提示信息</li><li><strong>name</strong>：错误名称（非标准属性）</li><li><strong>stack</strong>：错误的堆栈（非标准属性）</li></ul><h4 id="2-原生错误类型"><a href="#2-原生错误类型" class="headerlink" title="2. 原生错误类型"></a>2. 原生错误类型</h4><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在**<code>Error</code>的6个派生对象****。</p><p><strong>2.1 SyntaxError 对象</strong></p><p><code>SyntaxError</code>对象是解析代码时发生的<strong>语法错误</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 变量名错误</span><br><span class="hljs-keyword">let</span> 1a;<br><span class="hljs-comment">// Uncaught SyntaxError: Invalid or unexpected token</span><br><br><span class="hljs-comment">// 缺少括号</span><br><span class="hljs-built_in">console</span>.log <span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-comment">// Uncaught SyntaxError: Unexpected string</span><br></code></pre></td></tr></table></figure><p><strong>2.2 ReferenceError 对象</strong></p><p><code>ReferenceError</code>对象是<strong>引用一个不存在的变量</strong>时发生的错误</p><p>另一种触发场景是，将一个<strong>值分配给无法分配的对象</strong>，比如对函数的运行结果赋值。</p><p><strong>2.3 RangeError 对象</strong></p><p><code>RangeError</code>对象是一个值<strong>超出有效范围</strong>时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p><p><strong>2.4 TypeError 对象</strong></p><p><code>TypeError</code>对象是变量或参数<strong>不是预期类型</strong>时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p><p><strong>2.5 URLError 对象</strong></p><p><code>URIError</code>对象是 URI 相关函数的<strong>参数不正确</strong>时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p><p>2.6 EvalError 对象</p><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p><h5 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h5><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是<strong>构造函数</strong>。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p><h4 id="3-自定义错误"><a href="#3-自定义错误" class="headerlink" title="3. 自定义错误"></a>3. 自定义错误</h4><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserError</span>(<span class="hljs-params">message</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.message = message || <span class="hljs-string">&#x27;默认信息&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;UserError&#x27;</span>;<br>&#125;<br><br>UserError.prototype = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>UserError.prototype.constructor = UserError;<br></code></pre></td></tr></table></figure><p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> UserError(<span class="hljs-string">&#x27;这是自定义的错误！&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="4-throw-语句"><a href="#4-throw-语句" class="headerlink" title="4. throw 语句"></a>4. throw 语句</h4><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = -<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;x 必须为正数&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// Uncaught Error: x 必须为正数</span><br></code></pre></td></tr></table></figure><h4 id="5-try…catch-结构"><a href="#5-try…catch-结构" class="headerlink" title="5. try…catch 结构"></a>5. try…catch 结构</h4><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了!&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  <span class="hljs-built_in">console</span>.log(e.stack);<br>&#125;<br><span class="hljs-comment">// Error: 出错了!</span><br><span class="hljs-comment">//   at &lt;anonymous&gt;:2:9</span><br><span class="hljs-comment">//   ...</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，<strong>转到<code>catch</code>代码块</strong>，或者说<strong>错误（Error）被<code>catch</code>代码块捕获了</strong>。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p><blockquote><p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">try</span> &#123;<br>  f();<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-comment">// 处理错误</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;出错了&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);<br><span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure><p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">try</span> &#123;<br>  foo.bar();<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">EvalError</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RangeError</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h4 id="6-finally-代码块"><a href="#6-finally-代码块" class="headerlink" title="6. finally 代码块"></a>6. finally 代码块</h4><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleansUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了……&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;此行不会执行&#x27;</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成清理工作&#x27;</span>);<br>  &#125;<br>&#125;<br><br>cleansUp()<br><span class="hljs-comment">// 完成清理工作</span><br><span class="hljs-comment">// Uncaught Error: 出错了……</span><br><span class="hljs-comment">//    at cleansUp (&lt;anonymous&gt;:3:11)</span><br><span class="hljs-comment">//    at &lt;anonymous&gt;:10:1</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于没有<code>catch</code>语句块，<strong>一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idle</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result&#x27;</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;FINALLY&#x27;</span>);<br>  &#125;<br>&#125;<br><br>idle(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-comment">// hello</span><br><span class="hljs-comment">// FINALLY</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块<strong>没有发生错误</strong>，而且里面还<strong>包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行</strong>。而且，这个函数的返回值还是<code>result</code>。<u><strong><code>return</code>语句的执行是排在<code>finally</code>代码之前</strong></u>，只是<strong>等<code>finally</code>代码执行完毕后才返回</strong>。</p><p>下面是<code>finally</code>代码块用法的典型场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">openFile();<br><br><span class="hljs-keyword">try</span> &#123;<br>  writeFile(Data);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  handleError(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  closeFile();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p><p><strong>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;bug&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 这句原本会延迟到 finally 代码块结束再执行</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">// 不会运行</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 这句会覆盖掉前面那句 return</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>); <span class="hljs-comment">// 不会运行</span><br>  &#125;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>); <span class="hljs-comment">// 不会运行</span><br>&#125;<br><br><span class="hljs-keyword">let</span> result = f();<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><br>result<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>代码块<strong>结束执行（return）之前</strong>，会先执行<code>finally</code>代码块。</p><p><code>catch</code>代码块之中，触发<strong>转入<code>finally</code><strong>代码块的标志，</strong>不仅有<code>return</code>语句，还有<code>throw</code>语句。</strong></p><p><strong><code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</strong></p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scilab"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    consle.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>); <span class="hljs-comment">// 报错（console拼错了）</span><br>  &#125;<br>  finally &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Finally&#x27;</span>);<br>  &#125;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Will I run?&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>) &#123;<br>  console.<span class="hljs-built_in">error</span>(error.message);<br>&#125;<br><span class="hljs-comment">// Finally</span><br><span class="hljs-comment">// consle is not defined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p><h2 id="1-3-编程风格"><a href="#1-3-编程风格" class="headerlink" title="1.3 编程风格"></a>1.3 编程风格</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>“编程风格”（programming style）指的是编写代码的样式规则。</p><h3 id="2-缩进"><a href="#2-缩进" class="headerlink" title="2. 缩进"></a>2. 缩进</h3><p>tab</p><h3 id="3-区块"><a href="#3-区块" class="headerlink" title="3. 区块"></a>3. 区块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (a)<br>  b();<br>  c();<br></code></pre></td></tr></table></figure><p>上面代码的原意可能是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (a) &#123;<br>  b();<br>  c();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，实际效果却是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (a) &#123;<br>  b();<br>&#125;<br>  c();<br></code></pre></td></tr></table></figure><p>建议总是使用大括号表示区块。****</p><p><strong>起首的大括号跟在关键字的后面</strong>。因为JavaScript 会<strong>自动添加句末的分号</strong>，导致一些难以察觉的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">return</span><br>&#123;<br>  <span class="hljs-attr">key</span>: value<br>&#125;;<br><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-keyword">return</span>;<br>&#123;<br>  <span class="hljs-attr">key</span>: value<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-圆括号"><a href="#4-圆括号" class="headerlink" title="4. 圆括号"></a>4. 圆括号</h3><p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示<strong>函数的调用</strong>，另一种表示<strong>表达式的组合（grouping）</strong>。</p><p>建议可以<strong>用空格，区分这两种不同的括号</strong>。</p><blockquote><ol><li>表示函数调用时，函数名与左括号之间没有空格。</li><li>表示函数定义时，函数名与左括号之间没有空格。</li><li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</li></ol></blockquote><h3 id="5-行尾的分号"><a href="#5-行尾的分号" class="headerlink" title="5. 行尾的分号"></a>5. 行尾的分号</h3><p>分号表示一条语句的结束。JavaScript 允许省略行尾的分号。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号。</p><h4 id="5-1-不使用分号的情况"><a href="#5-1-不使用分号的情况" class="headerlink" title="5.1 不使用分号的情况"></a>5.1 <strong>不使用分号的情况</strong></h4><p>首先，以下三种情况，语法规定本来就不需要在结尾添加分号。</p><p><strong>（1）for 和 while 循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> ( ; ; ) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></td></tr></table></figure><p><strong>注意，<code>do...while</code>循环是有分号的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">do</span> &#123;<br>  a--;<br>&#125; <span class="hljs-keyword">while</span>(a &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 分号不能省略</span><br></code></pre></td></tr></table></figure><p><strong>（2）分支语句：if，switch，try</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">switch</span> () &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">try</span> &#123;<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></td></tr></table></figure><p><strong>（3）函数的声明语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></td></tr></table></figure><p>注意，<strong>函数表达式仍然要使用分号</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上三种情况，如果使用了分号，并不会出错。因为，<strong>解释引擎</strong>会<strong>把这个分号解释为空语句。</strong></p><h4 id="5-2-分号的自动添加"><a href="#5-2-分号的自动添加" class="headerlink" title="5.2 分号的自动添加"></a>5.2 <strong>分号的自动添加</strong></h4><p>除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，<strong>大多数情况下</strong>，JavaScript 会<strong>自动添加</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这种语法特性被称为“<strong>分号的自动添加</strong>”（Automatic Semicolon Insertion，简称 <strong>ASI</strong>）。</p><p>由于解释引擎自动添加分号的行为<strong>难以预测</strong>，因此编写代码的时候不应该省略行尾的分号。</p><p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">;<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>上面这种写法就可以<strong>避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号</strong>，导致运行出错的问题。</p><h3 id="6-全局变量"><a href="#6-全局变量" class="headerlink" title="6. 全局变量"></a>6. 全局变量</h3><p>JavaScript 最大的语法缺点，可能就是<strong>全局变量对于任何一个代码块，都是可读可写。</strong>这对代码的模块化和重复使用，非常不利。</p><p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用<strong>大写字母表示变量名</strong>，这样更容易看出这是全局变量，**比如<code>UPPER_CASE</code>**。</p><h3 id="7-变量声明"><a href="#7-变量声明" class="headerlink" title="7. 变量声明"></a>7. 变量声明</h3><p>JavaScript 会自动将变量声明“提升”（hoist）到代码块（block）的头部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!x) &#123;<br>  <span class="hljs-keyword">var</span> x = &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> x;<br><span class="hljs-keyword">if</span> (!x) &#123;<br>  x = &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，<strong>所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</strong></p><h3 id="8-with-语句"><a href="#8-with-语句" class="headerlink" title="8. with 语句"></a>8. with 语句</h3><p>不要使用<code>with</code>语句。。。。。。</p><h2 id="1-4-console对象与控制台"><a href="#1-4-console对象与控制台" class="headerlink" title="1.4 console对象与控制台"></a>1.4 console对象与控制台</h2><h3 id="1-console对象"><a href="#1-console对象" class="headerlink" title="1. console对象"></a>1. console对象</h3><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p><p><code>console</code>的常见用途有两个。</p><ul><li><strong>调试程序</strong>，显示网页代码运行时的错误信息。</li><li>提供了一个<strong>命令行接口</strong>，用来<strong>与网页代码互动</strong>。</li></ul><h3 id="2-console对象的静态方法"><a href="#2-console对象的静态方法" class="headerlink" title="2. console对象的静态方法"></a>2. console对象的静态方法</h3><p><strong>2.1 console.log()，console.info()，console.debug()</strong></p><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br><span class="hljs-comment">// Hello World</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-comment">// a b c</span><br></code></pre></td></tr></table></figure><p><code>console.log</code>方法会自动在每次输出的<strong>结尾，添加换行符</strong>。</p><ul><li><code>%s</code> 字符串</li><li><code>%d</code> 整数</li><li><code>%i</code> 整数</li><li><code>%f</code> 浮点数</li><li><code>%o</code> 对象的链接</li><li><code>%c</code> CSS 格式字符串</li></ul><p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<br>  <span class="hljs-string">&#x27;%cThis text is styled!&#x27;</span>,<br>  <span class="hljs-string">&#x27;color: red; background: yellow; font-size: 24px;&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>上面代码运行后，输出的内容将显示为<strong>黄底红字。</strong></p><p><code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27; %s + %s &#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;= 2&#x27;</span>)<br><span class="hljs-comment">// 1 + 1  = 2</span><br></code></pre></td></tr></table></figure><p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个<strong>蓝色图标</strong>。</p><p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台<strong>输出调试信息</strong>。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</p><p><strong>2.2 console.warn()，console.error()</strong></p><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p><p><strong>2.3 console.table()</strong></p><p>对于某些复合类型的数据，console.table方法可将其<strong>转为表格显示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> languages = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.js&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.ts&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;CoffeeScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.coffee&quot;</span> &#125;<br>];<br><br><span class="hljs-built_in">console</span>.table(languages);<br></code></pre></td></tr></table></figure><p>上面代码的<code>language</code>变量，转为表格显示如下：</p><table><thead><tr><th>(index)</th><th>name</th><th>fileExtension</th></tr></thead><tbody><tr><td>0</td><td>“JavaScript”</td><td>“.js”</td></tr><tr><td>1</td><td>“TypeScript”</td><td>“.ts”</td></tr><tr><td>2</td><td>“CoffeeScript”</td><td>“.coffee”</td></tr></tbody></table><p>下面是显示表格内容的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> languages = &#123;<br>  <span class="hljs-attr">csharp</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C#&quot;</span>, <span class="hljs-attr">paradigm</span>: <span class="hljs-string">&quot;object-oriented&quot;</span> &#125;,<br>  <span class="hljs-attr">fsharp</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;F#&quot;</span>, <span class="hljs-attr">paradigm</span>: <span class="hljs-string">&quot;functional&quot;</span> &#125;<br>&#125;;<br><br><span class="hljs-built_in">console</span>.table(languages);<br></code></pre></td></tr></table></figure><p>上面代码的<code>language</code>，转为表格显示如下。</p><table><thead><tr><th>(index)</th><th>name</th><th>paradigm</th></tr></thead><tbody><tr><td>csharp</td><td>“C#”</td><td>“object-oriented”</td></tr><tr><td>fsharp</td><td>“F#”</td><td>“functional”</td></tr></tbody></table><p><strong>2.4 console.count()</strong></p><p><code>count</code>方法用于计数，输出<strong>它</strong>被调用了多少次。</p><p>该方法可直接调用console.count()</p><p><strong>也可以接受一个字符串作为参数</strong>，作为标签，对执行次数进行分类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.count(user);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi &quot;</span> + user;<br>&#125;<br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">// bob: 1</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br><br>greet(<span class="hljs-string">&#x27;alice&#x27;</span>)<br><span class="hljs-comment">// alice: 1</span><br><span class="hljs-comment">// &quot;hi alice&quot;</span><br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">// bob: 2</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p><p><strong>2.5 console.dir()，console.dirxml()</strong></p><p><code>dir</code>方法用来<strong>对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">console</span>.log(&#123;<span class="hljs-attr">f1</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">f2</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;</span><br><br><span class="hljs-built_in">console</span>.dir(&#123;<span class="hljs-attr">f1</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">f2</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">//   f1: &quot;foo&quot;</span><br><span class="hljs-comment">//   f2: &quot;bar&quot;</span><br><span class="hljs-comment">//   __proto__: Object</span><br></code></pre></td></tr></table></figure><p>该方法对于输出 DOM 对象非常有用，因为会显示 <strong>DOM 对象的所有属性</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">console</span>.dir(<span class="hljs-built_in">document</span>.body)<br></code></pre></td></tr></table></figure><p>Node 环境之中，还可以<strong>指定以代码高亮的形式输出</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">console</span>.dir(obj, &#123;<span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><p><code>dirxml</code>方法主要用于以目录树的形式，<strong>显示 DOM 节点</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">console</span>.dirxml(<span class="hljs-built_in">document</span>.body)<br></code></pre></td></tr></table></figure><p><strong>2.6 console.assert()</strong></p><p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数(但不会中断程序执行。这样就相当于提示用户，内部状态不正确)，否则不会有任何结果。</p><p><strong>2.7 console.time()，console.timeEnd()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;Array initialize&#x27;</span>);<br><br><span class="hljs-keyword">let</span> array= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>  array[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>&#125;;<br><br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;Array initialize&#x27;</span>);<br><span class="hljs-comment">// Array initialize: 1914.481ms</span><br></code></pre></td></tr></table></figure><p><strong>2.8 console.group()，console.groupEnd()，console.groupCollapsed()</strong> </p><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.group(<span class="hljs-string">&#x27;一级分组&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;一级分组的内容&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.group(<span class="hljs-string">&#x27;二级分组&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;二级分组的内容&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.groupEnd(); <span class="hljs-comment">// 二级分组结束</span><br><span class="hljs-built_in">console</span>.groupEnd(); <span class="hljs-comment">// 一级分组结束</span><br></code></pre></td></tr></table></figure><p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。</p><p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p><p><strong>2.9 console.trace()，console.clear()</strong></p><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p><p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p><h3 id="3-控制台命令行API"><a href="#3-控制台命令行API" class="headerlink" title="3. 控制台命令行API"></a>3. 控制台命令行API</h3><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。</p><p>（1）<code>$_</code></p><p><code>$_</code>属性返回上一个表达式的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span> + <span class="hljs-number">2</span><br><span class="hljs-comment">// 4</span><br>$_<br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>（2）<code>$0</code> - <code>$4</code></p><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p><p>（3）<code>$(selector)</code></p><p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p><p>（4）<code>$$(selector)</code></p><p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p><p>（5）<code>$x(path)</code></p><p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$x(<span class="hljs-string">&quot;//p[a]&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p><p>（6）<code>inspect(object)</code></p><p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p><p>（7）<code>getEventListeners(object)</code></p><p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p><p>（8）<code>keys(object)</code>，<code>values(object)</code></p><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p><p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = &#123;<span class="hljs-string">&#x27;p1&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p2&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;;<br><br>keys(o)<br><span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br>values(o)<br><span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p><p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">monitorEvents(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;resize&quot;</span>);<br>monitorEvents(<span class="hljs-built_in">window</span>, [<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-string">&quot;scroll&quot;</span>])<br></code></pre></td></tr></table></figure><p>上面代码分别表示单个事件和多个事件的监听方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">monitorEvents($<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;mouse&#x27;</span>);<br>unmonitorEvents($<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;mousemove&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码表示如何停止监听。</p><p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p><ul><li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li><li>key：”keydown”, “keyup”, “keypress”, “textInput”</li><li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li><li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">monitorEvents($(<span class="hljs-string">&quot;#msg&quot;</span>), <span class="hljs-string">&quot;key&quot;</span>);<br></code></pre></td></tr></table></figure><p>上面代码表示监听所有<code>key</code>大类的事件。</p><p>（10）其他方法</p><p>命令行 API 还提供以下方法。</p><ul><li><code>clear()</code>：清除控制台的历史。</li><li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li><li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li><li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li></ul><h3 id="4-debugger语句"><a href="#4-debugger语句" class="headerlink" title="4. debugger语句"></a>4. debugger语句</h3><p><code>debugger</code>语句主要用于除错，作用是设置断点</p><p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) <span class="hljs-keyword">debugger</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p><h2 id="2-标准库"><a href="#2-标准库" class="headerlink" title="2. 标准库"></a>2. 标准库</h2><h3 id="2-1-Object-对象"><a href="#2-1-Object-对象" class="headerlink" title="2.1 Object 对象"></a>2.1 Object 对象</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>JavaScript 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），本章介绍该对象原生的各种方法。</p><p><strong>JavaScript 的所有其他对象都继承自<code>Object</code>对象，即那些对象都是<code>Object</code>的实例。</strong></p><p><code>Object</code>对象的原生方法分成两类：<code>Object</code><strong>本身的方法与<code>Object</code>的实例方法</strong>。</p><h4 id="2-Object"><a href="#2-Object" class="headerlink" title="2. Object()"></a>2. Object()</h4><p><code>Object</code><strong>本身是一个函数</strong>，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p><p>如果参数为空（或者为<code>undefined</code>和<code>null</code>），<code>Object()</code>返回一个空对象。</p><p>如果参数是原始类型的值，<code>Object</code>方法将其转为<strong>对应的包装对象的实例</strong></p><p>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象</p><h4 id="3-Object-构造函数"><a href="#3-Object-构造函数" class="headerlink" title="3. Object 构造函数"></a>3. Object 构造函数</h4><p><code>Object</code>构造函数的首要用途，是直接通过它来生成新对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure><h4 id="4-Object-的静态方法"><a href="#4-Object-的静态方法" class="headerlink" title="4. Object 的静态方法"></a>4. Object 的静态方法</h4><p><code>Object</code>对象自身的方法。</p><h5 id="4-1-Object-keys-，Object-getOwnPropertyNames"><a href="#4-1-Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="4.1 Object.keys()，Object.getOwnPropertyNames()"></a><strong>4.1 Object.keys()，Object.getOwnPropertyNames()</strong></h5><p><code>Object.keys</code>方法的<strong>参数是一个对象</strong>，返回一个数组。该<strong>数组的成员</strong>都是<strong>该对象自身</strong>的（而不是继承的）所有<strong>属性名</strong>。</p><p><code>Object.keys</code>方法<strong>只返回可枚举的属性</strong>（详见《对象属性的描述对象》一章），<code>Object.getOwnPropertyNames</code>方法<strong>还返回不可枚举的属性名。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>];<br><br><span class="hljs-built_in">Object</span>.keys(a) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;]</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(a) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<strong>数组的<code>length</code>属性是不可枚举的属性</strong>，所以只出现在<code>Object.getOwnPropertyNames</code>方法的返回结果中。</p><p>由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">p1</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">p2</span>: <span class="hljs-number">456</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj).length <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj).length <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>一般情况下，几乎总是使用<code>Object.keys</code>方法，遍历对象的属性。</strong></p><h5 id="4-2-其他方法"><a href="#4-2-其他方法" class="headerlink" title="4.2 其他方法"></a><strong>4.2 其他方法</strong></h5><h6 id="（1）对象属性模型的相关方法"><a href="#（1）对象属性模型的相关方法" class="headerlink" title="（1）对象属性模型的相关方法"></a><strong>（1）对象属性模型的相关方法</strong></h6><ul><li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li><li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性。</li><li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</li></ul><h6 id="（2）控制对象状态的方法"><a href="#（2）控制对象状态的方法" class="headerlink" title="（2）控制对象状态的方法"></a><strong>（2）控制对象状态的方法</strong></h6><ul><li><code>Object.preventExtensions()</code>：防止对象扩展。</li><li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li><li><code>Object.seal()</code>：禁止对象配置。</li><li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li><li><code>Object.freeze()</code>：冻结一个对象。</li><li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li></ul><h6 id="（3）原型链相关方法"><a href="#（3）原型链相关方法" class="headerlink" title="（3）原型链相关方法"></a><strong>（3）原型链相关方法</strong></h6><ul><li><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。</li><li><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</li></ul><h4 id="5-Object-的实例方法"><a href="#5-Object-的实例方法" class="headerlink" title="5. Object 的实例方法"></a>5. Object 的实例方法</h4><p>除了静态方法，还有不少<strong>方法定义在<code>Object.prototype</code>对象。它们称为实例方法</strong>，所有<code>Object</code>的实例对象都继承了这些方法。</p><p><code>Object</code>实例对象的方法，主要有以下六个。</p><ul><li><code>Object.prototype.valueOf()</code>：返回当前对象<strong>对应的值</strong>。</li><li><code>Object.prototype.toString()</code>：返回当前对象对应的<strong>字符串形式。</strong></li><li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的<strong>本地字符串形式。</strong></li><li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li><li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li><li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li></ul><h5 id="5-1-Object-prototype-valueOf"><a href="#5-1-Object-prototype-valueOf" class="headerlink" title="5.1 Object.prototype.valueOf()"></a><strong>5.1 Object.prototype.valueOf()</strong></h5><p><code>valueOf</code>方法的作用是<strong>返回一个对象的“值”，默认情况下返回对象本身。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.valueOf() === obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>valueOf</code>方法的主要用途是，JavaScript <strong>自动类型转换时会默认调用这个方法</strong></p><h5 id="5-2-Object-prototype-toString"><a href="#5-2-Object-prototype-toString" class="headerlink" title="5.2 Object.prototype.toString()"></a><strong>5.2 Object.prototype.toString()</strong></h5><p><code>toString</code>方法的作用是返回一个<strong>对象的字符串形式</strong>，默认情况下返回<strong>类型字符串</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o1.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-keyword">var</span> o2 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;;<br>o2.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型。</p><p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>obj.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>&#125;;<br><br>obj + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码表示，当对象用于字符串加法时，<strong>会自动调用<code>toString</code>方法。由于自定义了<code>toString</code>方法</strong>，所以返回字符串<code>hello world</code>。</p><p>数组、字符串、函数、Date 对象都分别部署了<strong>自定义的<code>toString</code>方法</strong>，覆盖了<code>Object.prototype.toString</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].toString() <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><br><span class="hljs-string">&#x27;123&#x27;</span>.toString() <span class="hljs-comment">// &quot;123&quot;</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>&#125;).toString()<br><span class="hljs-comment">// &quot;function () &#123;</span><br><span class="hljs-comment">//   return 123;</span><br><span class="hljs-comment">// &#125;&quot;</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toString()<br><span class="hljs-comment">// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><h5 id="5-3-toString-的应用：判断数据类型"><a href="#5-3-toString-的应用：判断数据类型" class="headerlink" title="5.3 toString() 的应用：判断数据类型"></a><strong>5.3 toString() 的应用：判断数据类型</strong></h5><p><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>obj.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码调用空对象的<code>toString</code>方法，结果返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示<strong>该值的构造函数</strong>。这是一个十分有用的判断数据类型的方法。</p><p>不同数据类型的**<code>Object.prototype.toString</code>方法返回值**如下。</p><ul><li>数值：返回<code>[object Number]</code>。</li><li>字符串：返回<code>[object String]</code>。</li><li>布尔值：返回<code>[object Boolean]</code>。</li><li>undefined：返回<code>[object Undefined]</code>。</li><li>null：返回<code>[object Null]</code>。</li><li>数组：返回<code>[object Array]</code>。</li><li>arguments 对象：返回<code>[object Arguments]</code>。</li><li>函数：返回<code>[object Function]</code>。</li><li>Error 对象：返回<code>[object Error]</code>。</li><li>Date 对象：返回<code>[object Date]</code>。</li><li>RegExp 对象：返回<code>[object RegExp]</code>。</li><li>其他对象：返回<code>[object Object]</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;[object Number]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// &quot;[object String]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;[object Boolean]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;[object Null]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Math</span>) <span class="hljs-comment">// &quot;[object Math]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call([]) <span class="hljs-comment">// &quot;[object Array]&quot;</span><br></code></pre></td></tr></table></figure><p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> type = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Object</span>.prototype.toString.call(o);<br>  <span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/\[object (.*?)\]/</span>)[<span class="hljs-number">1</span>].toLowerCase();<br>&#125;;<br><br>type(&#123;&#125;); <span class="hljs-comment">// &quot;object&quot;</span><br>type([]); <span class="hljs-comment">// &quot;array&quot;</span><br>type(<span class="hljs-number">5</span>); <span class="hljs-comment">// &quot;number&quot;</span><br>type(<span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;null&quot;</span><br>type(); <span class="hljs-comment">// &quot;undefined&quot;</span><br>type(<span class="hljs-regexp">/abcd/</span>); <span class="hljs-comment">// &quot;regex&quot;</span><br>type(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()); <span class="hljs-comment">// &quot;date&quot;</span><br></code></pre></td></tr></table></figure><p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> type = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Object</span>.prototype.toString.call(o);<br>  <span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/\[object (.*?)\]/</span>)[<span class="hljs-number">1</span>].toLowerCase();<br>&#125;;<br><br>[<span class="hljs-string">&#x27;Null&#x27;</span>,<br> <span class="hljs-string">&#x27;Undefined&#x27;</span>,<br> <span class="hljs-string">&#x27;Object&#x27;</span>,<br> <span class="hljs-string">&#x27;Array&#x27;</span>,<br> <span class="hljs-string">&#x27;String&#x27;</span>,<br> <span class="hljs-string">&#x27;Number&#x27;</span>,<br> <span class="hljs-string">&#x27;Boolean&#x27;</span>,<br> <span class="hljs-string">&#x27;Function&#x27;</span>,<br> <span class="hljs-string">&#x27;RegExp&#x27;</span><br>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>&#123;<br>  type[<span class="hljs-string">&#x27;is&#x27;</span> + t] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> type(o) === t.toLowerCase();<br>  &#125;;<br>&#125;);<br><br>type.isObject(&#123;&#125;) <span class="hljs-comment">// true</span><br>type.isNumber(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br>type.isRegExp(<span class="hljs-regexp">/abc/</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="5-4-Object-prototype-toLocaleString"><a href="#5-4-Object-prototype-toLocaleString" class="headerlink" title="5.4 Object.prototype.toLocaleString()"></a><strong>5.4 Object.prototype.toLocaleString()</strong></h5><p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>obj.toString(obj) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>obj.toLocaleString(obj) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>这个方法的主要作用是<strong>留出一个接口</strong>，让各种不同的对象**实现自己版本的<code>toLocaleString</code>**，用来返回针对某些地域的特定的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Henry Norman Bethune&#x27;</span>;<br>  &#125;,<br>  <span class="hljs-attr">toLocaleString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;白求恩&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>person.toString() <span class="hljs-comment">// Henry Norman Bethune</span><br>person.toLocaleString() <span class="hljs-comment">// 白求恩</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>toString()</code>方法返回对象的一般字符串形式，<code>toLocaleString()</code>方法返回本地的字符串形式。</p><h5 id="5-5-Object-prototype-hasOwnProperty"><a href="#5-5-Object-prototype-hasOwnProperty" class="headerlink" title="5.5 Object.prototype.hasOwnProperty()"></a><strong>5.5 Object.prototype.hasOwnProperty()</strong></h5><p><code>Object.prototype.hasOwnProperty</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。</p><h3 id="2-2-属性的描述对象"><a href="#2-2-属性的描述对象" class="headerlink" title="2.2 属性的描述对象"></a><strong>2.2 属性的描述对象</strong></h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>JavaScript 提供了一个内部数据结构，用来<strong>描述(<strong>对象的)<strong>属性</strong>，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“</strong>属性描述对象</strong>”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p><h4 id="2-Object-getOwnPropertyDescriptor"><a href="#2-Object-getOwnPropertyDescriptor" class="headerlink" title="2. Object.getOwnPropertyDescriptor()"></a>2. Object.getOwnPropertyDescriptor()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-comment">// Object &#123; value: &quot;a&quot;,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: true</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>只能用于对象自身的属性，<strong>不能用于继承的属性。</strong></p><h4 id="3-Object-getOwnPropertyNames"><a href="#3-Object-getOwnPropertyNames" class="headerlink" title="3. Object.getOwnPropertyNames()"></a>3. Object.getOwnPropertyNames()</h4><p>返回一个数组，成员是参数对象<strong>自身的全部属性的属性名</strong>，不管该属性是否可遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  <span class="hljs-attr">p1</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">p2</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span> &#125;<br>&#125;);<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj)<br><span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></code></pre></td></tr></table></figure><p>这跟<code>Object.keys</code>的行为不同，<code>Object.keys</code>只返回对象自身的可遍历属性的全部属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.keys([]) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames([]) <span class="hljs-comment">// [ &#x27;length&#x27; ]</span><br><br><span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(<span class="hljs-built_in">Object</span>.prototype)<br><span class="hljs-comment">// [&#x27;hasOwnProperty&#x27;,</span><br><span class="hljs-comment">//  &#x27;valueOf&#x27;,</span><br><span class="hljs-comment">//  &#x27;constructor&#x27;,</span><br><span class="hljs-comment">//  &#x27;toLocaleString&#x27;,</span><br><span class="hljs-comment">//  &#x27;isPrototypeOf&#x27;,</span><br><span class="hljs-comment">//  &#x27;propertyIsEnumerable&#x27;,</span><br><span class="hljs-comment">//  &#x27;toString&#x27;]</span><br></code></pre></td></tr></table></figure><h4 id="4-Object-defineProperty-，Object-defineProperties"><a href="#4-Object-defineProperty-，Object-defineProperties" class="headerlink" title="4. Object.defineProperty()，Object.defineProperties()"></a>4. Object.defineProperty()，Object.defineProperties()</h4><p><code>Object.defineProperty()</code>方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Object</span>.defineProperty(object, propertyName, attributesObject)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.p <span class="hljs-comment">// 123</span><br><br>obj.p = <span class="hljs-number">246</span>;<br>obj.p <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p><strong>这里的<code>Object.defineProperty</code>方法的第一个参数是<code>&#123;&#125;</code>（一个新建的空对象），<code>p</code>属性直接定义在这个空对象上面，然后返回这个对象。</strong></p><p>如果一次性定义或修改<strong>多个属性</strong>，可以使用<code>Object.defineProperties()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  <span class="hljs-attr">p1</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">p2</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">p3</span>: &#123; <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.p1 + <span class="hljs-built_in">this</span>.p2 &#125;,<br>    <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><br>obj.p1 <span class="hljs-comment">// 123</span><br>obj.p2 <span class="hljs-comment">// &quot;abc&quot;</span><br>obj.p3 <span class="hljs-comment">// &quot;123abc&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.defineProperties()</code>同时定义了<code>obj</code>对象的三个属性。其中，<code>p3</code>属性定义了取值函数<code>get</code>，即每次读取该属性，都会调用这个取值函数。注意，<strong>一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性</strong>，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>; &#125;<br>&#125;);<br><span class="hljs-comment">// TypeError: Invalid property.</span><br><span class="hljs-comment">// A property cannot both have accessors and be writable or have a value</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>; &#125;<br>&#125;);<br><span class="hljs-comment">// TypeError: Invalid property descriptor.</span><br><span class="hljs-comment">// Cannot both specify accessors and a value or writable attribute</span><br></code></pre></td></tr></table></figure><p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>。</p><h4 id="5-Object-prototype-propertyIsEnumerable"><a href="#5-Object-prototype-propertyIsEnumerable" class="headerlink" title="5. Object.prototype.propertyIsEnumerable()"></a>5. Object.prototype.propertyIsEnumerable()</h4><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>obj.p = <span class="hljs-number">123</span>;<br><br>obj.propertyIsEnumerable(<span class="hljs-string">&#x27;p&#x27;</span>) <span class="hljs-comment">// true</span><br>obj.propertyIsEnumerable(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="6-元属性"><a href="#6-元属性" class="headerlink" title="6. 元属性"></a>6. 元属性</h4><p><strong>6.1 value</strong> </p><p><strong>6.2 writable</strong></p><p><strong>6.3 enumerable(遍历)</strong></p><p>**6.4 configurable(可配置性)**：决定了是否可以修改属性描述对象。也就是说，<code>configurable</code>为<code>false</code>时，<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了。</p><h4 id="7-存取器"><a href="#7-存取器" class="headerlink" title="7. 存取器"></a>7. 存取器</h4><p>除了直接定义以外，属性还可以用<strong>存取器（accessor）定义</strong>。其中，**存值函数称为<code>setter</code><strong>，使用属性描述对象的<code>set</code>属性；</strong>取值函数称为<code>getter</code>**，使用属性描述对象的<code>get</code>属性。</p><p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;);<br><br>obj.p <span class="hljs-comment">// &quot;getter&quot;</span><br>obj.p = <span class="hljs-number">123</span> <span class="hljs-comment">// &quot;setter: 123&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>。</p><p>JavaScript 还提供了存取器的另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">p</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>  &#125;,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">p</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面两种写法，虽然属性<code>p</code>的读取和赋值行为是一样的，但是有一些细微的区别。第一种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>false</code>，从而导致属性<code>p</code>是不可遍历的；<strong>第二种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>true</code>，</strong>因此属性<code>p</code>是可遍历的。实际开发中，写法二更常用。</p><p>存取器往往用于<strong>属性的值依赖对象内部数据的场合</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj =&#123;<br>  <span class="hljs-attr">$n</span> : <span class="hljs-number">5</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">next</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$n++ &#125;,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">next</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-built_in">this</span>.$n) <span class="hljs-built_in">this</span>.$n = n;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;新的值必须大于当前值&#x27;</span>);<br>  &#125;<br>&#125;;<br><br>obj.next <span class="hljs-comment">// 5</span><br><br>obj.next = <span class="hljs-number">10</span>;<br>obj.next <span class="hljs-comment">// 10</span><br><br>obj.next = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// Uncaught Error: 新的值必须大于当前值</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>next</code>属性的存值函数和取值函数，都依赖于内部属性<code>$n</code>。</p><h4 id="8-对象的拷贝"><a href="#8-对象的拷贝" class="headerlink" title="8. 对象的拷贝"></a>8. 对象的拷贝</h4><p>通过<code>Object.defineProperty</code>方法来拷贝属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> property <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>.hasOwnProperty(property)) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">Object</span>.defineProperty(<br>      to,<br>      property,<br>      <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-keyword">from</span>, property)<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br><br>extend(&#123;&#125;, &#123; <span class="hljs-keyword">get</span> <span class="hljs-title">a</span>()&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125; &#125;)<br><span class="hljs-comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span><br></code></pre></td></tr></table></figure><p>上面代码中，**<code>hasOwnProperty</code>那一行用来过滤掉继承的属性**，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象。</p><h4 id="9-控制对象状态"><a href="#9-控制对象状态" class="headerlink" title="9. 控制对象状态"></a>9. 控制对象状态</h4><p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p><h5 id="9-1-Object-preventExtensions"><a href="#9-1-Object-preventExtensions" class="headerlink" title="9.1 Object.preventExtensions()"></a>9.1 Object.preventExtensions()</h5><p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br></code></pre></td></tr></table></figure><h5 id="9-2-Object-isExtensible"><a href="#9-2-Object-isExtensible" class="headerlink" title="9.2 Object.isExtensible()"></a>9.2 Object.isExtensible()</h5><p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，<strong>检查是否可以为一个对象添加属性。</strong></p><h5 id="9-3-Object-seal"><a href="#9-3-Object-seal" class="headerlink" title="9.3 Object.seal()"></a>9.3 Object.seal()</h5><p><code>Object.seal</code>方法使得一个对象<strong>既无法添加新属性，也无法删除旧属性。</strong></p><p><code>Object.seal</code>实质是把**属性描述对象的<code>configurable</code>属性设为<code>false</code>**，因此属性描述对象不再能改变了。</p><p><code>Object.seal</code>只是禁止新增或删除属性，<strong>并不影响修改某个属性的值</strong>。</p><h5 id="9-4-Object-isSealed"><a href="#9-4-Object-isSealed" class="headerlink" title="9.4 Object.isSealed()"></a>9.4 Object.isSealed()</h5><p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.seal(obj);<br><span class="hljs-built_in">Object</span>.isSealed(obj) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h5 id="9-5-Object-freeze"><a href="#9-5-Object-freeze" class="headerlink" title="9.5 Object.freeze()"></a>9.5 Object.freeze()</h5><p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，<strong>使得这个对象实际上变成了常量</strong>。</p><h5 id="9-6-Object-isForzen"><a href="#9-6-Object-isForzen" class="headerlink" title="9.6 Object.isForzen()"></a>9.6 Object.isForzen()</h5><p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。</p><h5 id="9-7-局限性"><a href="#9-7-局限性" class="headerlink" title="9.7 局限性"></a>9.7 局限性</h5><p>上面的三个方法锁定对象的可写性有一个漏洞：<strong>可以通过改变原型对象，来为对象增加属性。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br>proto.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t<br><span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>本身不能新增属性，但是可以在它的<strong>原型对象(Object)上新增属性，就依然能够在<code>obj</code>上读到。</strong></p><p>一种解决方案是，<strong>把<code>obj</code>的原型也冻结住。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br><span class="hljs-built_in">Object</span>.preventExtensions(proto);<br><br>proto.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>另外一个局限是，<strong>如果属性值是对象</strong>，上面这些方法只能冻结<strong>属性指向的对象，而不能冻结对象本身的内容</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br>&#125;;<br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br>obj.bar.push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>obj.bar <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-Array-对象"><a href="#2-3-Array-对象" class="headerlink" title="2.3 Array 对象"></a>2.3 Array 对象</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p><code>Array</code>是 JavaScript 的原生对象，同时也是一个构造函数，可以用它<strong>生成新的数组。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br>arr.length <span class="hljs-comment">// 2</span><br>arr <span class="hljs-comment">// [ empty x 2 ]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Array()</code>构造函数的参数<code>2</code>，表示生成一个两个成员的数组，每个位置都是空值。</p><p>如果没有使用<code>new</code>关键字，运行结果也是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>考虑到语义性，以及与其他构造函数用法保持一致，<strong>建议总是加上<code>new</code>。</strong></p><p><strong><code>**Array()</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><h4 id="2-静态方法：Array-isArray"><a href="#2-静态方法：Array-isArray" class="headerlink" title="2. 静态方法：Array.isArray()"></a>2. 静态方法：Array.isArray()</h4><h4 id="3-实例方法"><a href="#3-实例方法" class="headerlink" title="3. 实例方法"></a>3. 实例方法</h4><h5 id="3-1-valueOf-，toString"><a href="#3-1-valueOf-，toString" class="headerlink" title="3.1 valueOf()，toString()"></a>3.1 valueOf()，toString()</h5><p><code>valueOf</code>方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的<code>valueOf</code>方法不尽一致，数组的<code>valueOf</code>方法返回数组本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.valueOf() <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><code>toString</code>方法也是对象的通用方法，数组的<code>toString</code>方法返回数组的字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.toString() <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br>arr.toString() <span class="hljs-comment">// &quot;1,2,3,4,5,6&quot;</span><br></code></pre></td></tr></table></figure><h5 id="3-2-push-，pop"><a href="#3-2-push-，pop" class="headerlink" title="3.2 push()，pop()"></a>3.2 push()，pop()</h5><blockquote><p>由于是对数组进行增删操作，故数组是动态的，实际使用中不仅需要返回增删的数组成员，还要更新原数组，故原数组会被改变</p></blockquote><p><code>push</code>方法用于<strong>在数组的末端添加一个或多个元素</strong>，<strong>并返回添加新元素后的数组长度</strong>。注意，该方法<strong>会改变原数组。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [];<br><br>arr.push(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>arr.push(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 2</span><br>arr.push(<span class="hljs-literal">true</span>, &#123;&#125;) <span class="hljs-comment">// 4</span><br>arr <span class="hljs-comment">// [1, &#x27;a&#x27;, true, &#123;&#125;]</span><br></code></pre></td></tr></table></figure><p><code>pop</code>方法用于删除数组的<strong>最后一个元素</strong>，并<strong>返回该元素</strong>，该方法<strong>会改变原数组</strong>。</p><p>对空数组使用<code>pop</code>方法，不会报错，而是返回<code>undefined</code>。</p><p><strong><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [];<br>arr.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>arr.push(<span class="hljs-number">3</span>);<br>arr.pop();<br>arr <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h5 id="3-3-shift-unshift"><a href="#3-3-shift-unshift" class="headerlink" title="3.3 shift(), unshift()"></a>3.3 shift(), unshift()</h5><p><code>shift()</code>方法用于<strong>删除数组的第一个元素，并返回该元素</strong>。注意，该方法<strong>会改变原数组。</strong></p><p><strong><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的队列结构（queue）。</strong></p><p><code>unshift()</code>方法用于在数组的<strong>第一个位置添加元素，并返回添加新元素后的数组长度</strong>。注意，该方法<strong>会改变原数组</strong>。</p><h5 id="3-4-join"><a href="#3-4-join" class="headerlink" title="3.4 join()"></a>3.4 join()</h5><p><strong><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回</strong>。如果不提供参数，默认用逗号分隔。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>a.join(<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// &#x27;1 2 3 4&#x27;</span><br>a.join(<span class="hljs-string">&#x27; | &#x27;</span>) <span class="hljs-comment">// &quot;1 | 2 | 3 | 4&quot;</span><br>a.join() <span class="hljs-comment">// &quot;1,2,3,4&quot;</span><br></code></pre></td></tr></table></figure><p>如果数组成员是**<code>undefined</code>或<code>null</code>或空位<strong>，会被</strong>转成空字符串**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>].join(<span class="hljs-string">&#x27;#&#x27;</span>)<br><span class="hljs-comment">// &#x27;#&#x27;</span><br><br>[<span class="hljs-string">&#x27;a&#x27;</span>,, <span class="hljs-string">&#x27;b&#x27;</span>].join(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &#x27;a--b&#x27;</span><br></code></pre></td></tr></table></figure><p>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.join.call(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &quot;h-e-l-l-o&quot;</span><br><br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">Array</span>.prototype.join.call(obj, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &#x27;a-b&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="3-5-concat"><a href="#3-5-concat" class="headerlink" title="3.5 concat()"></a>3.5 concat()</h5><blockquote><p>返回的是连接之后的数组，所以原数组不需要改变</p></blockquote><p><code>concat</code>方法用于<strong>多个数组的合并</strong>。它将新数组的成员，添加到原数组成员的<strong>后部</strong>，然后<strong>返回一个新数组，原数组不变</strong>。</p><p>除了数组作为参数，<code>concat</code>也接受其他类型的值作为参数，添加到目标数组尾部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].concat(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><h5 id="3-6-reverse"><a href="#3-6-reverse" class="headerlink" title="3.6 reverse()"></a>3.6 reverse()</h5><p><code>reverse</code>方法用于颠倒排列数组元素，<strong>返回改变后的数组</strong>。注意，该方法将<strong>改变原数组。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.reverse() <span class="hljs-comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br>a <span class="hljs-comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br></code></pre></td></tr></table></figure><h5 id="3-7-slice"><a href="#3-7-slice" class="headerlink" title="3.7 slice()"></a>3.7 slice()</h5><blockquote><p>返回数组中要提取的一部分，不改变原数组</p></blockquote><p><code>slice()</code>方法用于提取目标数组的一部分，<strong>返回一个新数组</strong>，原数组不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.slice(start, end);<br></code></pre></td></tr></table></figure><p>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为<strong>终止位置（但该位置的元素本身不包括在内）</strong>。<strong>如果省略第二个参数，则一直返回到原数组的最后一个成员。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.slice(<span class="hljs-number">0</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>a.slice(<span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;b&quot;, &quot;c&quot;]</span><br>a.slice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;b&quot;]</span><br>a.slice(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// [&quot;c&quot;]</span><br>a.slice() <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>如果<code>slice()</code>方法的参数是负数，负号表示<strong>倒数的位置。（倒数的时候起始值不是0是-1）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>a.slice(-<span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;b&quot;, &quot;c&quot;]</span><br>a.slice(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Array</span>.prototype.slice.call(&#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><br><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>));<br><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br></code></pre></td></tr></table></figure><p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组。</p><h5 id="3-8-splice"><a href="#3-8-splice" class="headerlink" title="3.8 splice()"></a>3.8 splice()</h5><blockquote><p>返回删除的元素，也可在数组删除位置添加成员，所以原数组被改变</p></blockquote><p><code>splice()</code>（<strong>拼接；接合</strong>）方法用于<strong>删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素</strong>。注意，该方法<strong>会改变原数组</strong>。</p><p><code>splice</code>的第一个参数是删除的起始位置（从0开始），<strong>第二个参数是被删除的元素个数</strong>。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arr.splice(start, count, addElement1, addElement2, ...);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;e&quot;, &quot;f&quot;]</span><br>a <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(-<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;c&quot;, &quot;d&quot;]</span><br></code></pre></td></tr></table></figure><p>如果只是单纯地**插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];<br><br>a.splice(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// []</span><br>a <span class="hljs-comment">// [1, 2, 1, 1]</span><br></code></pre></td></tr></table></figure><p>如果只提供第一个参数，等同于将原数组<strong>在指定位置拆分成两个数组</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>a.splice(<span class="hljs-number">2</span>) <span class="hljs-comment">// [3, 4]</span><br>a <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h5 id="3-9-sort"><a href="#3-9-sort" class="headerlink" title="3.9 sort()"></a>3.9 sort()</h5><p><code>sort</code>方法对数组成员<strong>进行排序</strong>，默认是<strong>按照字典顺序排序（数值会被先转成字符串）</strong>。排序后，<strong>原数组将被改变。</strong></p><p>如果想让<code>sort</code>方法<strong>按照自定义方式排序，可以传入一个函数作为参数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[<span class="hljs-number">10111</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">111</span>].sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a - b;<br>&#125;)<br><span class="hljs-comment">// [111, 1101, 10111]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p><p>注意，<strong>自定义的排序函数应该返回数值</strong>，否则不同的浏览器可能有不同的实现，不能保证结果都一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a &gt; b)<br><br><span class="hljs-comment">// good</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br></code></pre></td></tr></table></figure><p>上面代码中，前一种排序算法返回的是布尔值，这是不推荐使用的。后一种是数值，才是更好的写法。</p><h5 id="3-10-map"><a href="#3-10-map" class="headerlink" title="3.10 map()"></a>3.10 map()</h5><p><code>map()</code>方法将数组的<strong>所有成员依次传入参数函数</strong>，然后把<strong>每一次的执行结果组成一个新数组返回。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>numbers.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;);<br><span class="hljs-comment">// [2, 3, 4]</span><br><br>numbers<br><span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>numbers</code>数组的所有成员依次执行参数函数，<strong>运行结果组成一个新数组返回，原数组没有变化。</strong></p><p><code>map()</code>方法<strong>接受一个函数作为参数</strong>。该函数调用时，<code>map()</code>方法向它传入三个参数：<strong>当前成员、当前位置和数组本身。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem * index;<br>&#125;);<br><span class="hljs-comment">// [0, 2, 6]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>map()</code>方法的回调函数有三个参数，<code>elem</code>为当前成员的值，<code>index</code>为当前成员的位置，<code>arr</code>为原数组（<code>[1, 2, 3]</code>）。</p><p><code>map()</code>方法<strong>还可以接受第二个参数</strong>，用来绑定回调函数内部的<code>this</code>变量（详见《this 变量》一章）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[e];<br>&#125;, arr)<br><span class="hljs-comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面代码通过<code>map()</code>方法的<strong>第二个参数</strong>，<strong>将回调函数内部的<code>this</code>对象，指向<code>arr</code>数组。</strong></p><h5 id="3-11-forEach"><a href="#3-11-forEach" class="headerlink" title="3.11 forEach()"></a>3.11 forEach()</h5><p><code>forEach()</code>方法与<code>map()</code>方法很相似，<strong>也是对数组的所有成员依次执行参数函数</strong>。但是，**<code>forEach()</code>方法不返回值，只用来操作数据**。</p><blockquote><p>这就是说，如果数组遍历的目的是为了<strong>得到返回值，那么使用<code>map()</code>方法</strong>，否则使用<code>forEach()</code>方法。</p></blockquote><p><code>forEach()</code>的用法与<code>map()</code>方法一致，<strong>参数是一个函数</strong>，该函数同样接受三个参数：当前值、当前位置、整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">element, index, array</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[&#x27;</span> + index + <span class="hljs-string">&#x27;] = &#x27;</span> + element);<br>&#125;<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>].forEach(log);<br><span class="hljs-comment">// [0] = 2</span><br><span class="hljs-comment">// [1] = 5</span><br><span class="hljs-comment">// [2] = 9</span><br></code></pre></td></tr></table></figure><p><code>forEach()</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> out = [];<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.push(elem * elem);<br>&#125;, out);<br><br>out <span class="hljs-comment">// [1, 4, 9]</span><br></code></pre></td></tr></table></figure><p>上面代码中，空数组<code>out</code>是<code>forEach()</code>方法的第二个参数，结果，<strong>回调函数内部的<code>this</code>关键字就指向<code>out</code>。</strong></p><p>注意，**<code>forEach()</code>方法无法中断执行**，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环。</p><p><code>forEach()</code>方法也会<strong>跳过数组的空位</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> log = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(n + <span class="hljs-number">1</span>);<br>&#125;;<br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 3</span><br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><br>[<span class="hljs-number">1</span>, , <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h5 id="3-12filter"><a href="#3-12filter" class="headerlink" title="3.12filter()"></a>3.12filter()</h5><p><code>filter()</code>方法用于<strong>过滤数组成员</strong>，满足条件的成员组成一个<strong>新数组返回</strong>。</p><p>它的<strong>参数是一个函数</strong>，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法<strong>不会改变原数组</strong>。</p><blockquote><p>​    参数函数的返回值是作为filter的参数，用来判断是否选择返回此成员，也就达到了过滤的目的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (elem &gt; <span class="hljs-number">3</span>);<br>&#125;)<br><span class="hljs-comment">// [4, 5]</span><br></code></pre></td></tr></table></figure><p>上面代码将大于<code>3</code>的数组成员，作为一个新数组返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">false</span>];<br><br>arr.filter(<span class="hljs-built_in">Boolean</span>)<br><span class="hljs-comment">// [1, &quot;a&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>filter()</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员。</p><p><code>filter()</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>&#125;);<br><span class="hljs-comment">// [1, 3, 5]</span><br></code></pre></td></tr></table></figure><p>上面代码返回偶数位置的成员组成的新数组。</p><p><code>filter()</code>方法还可以<strong>接受第二个参数，用来绑定参数函数内部的<code>this</code>变量</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">MAX</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">var</span> myFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-built_in">this</span>.MAX) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<br>arr.filter(myFilter, obj) <span class="hljs-comment">// [8, 4, 9]</span><br></code></pre></td></tr></table></figure><p>上面代码中，过滤器<code>myFilter()</code>内部有<code>this</code>变量，它可以被<code>filter()</code>方法的第二个参数<code>obj</code>绑定，返回大于<code>3</code>的成员。</p><h5 id="3-13-some-，every"><a href="#3-13-some-，every" class="headerlink" title="3.13 some()，every()"></a>3.13 some()，every()</h5><blockquote><p>这两个方法类似“断言”（assert），返回一个布尔值，<strong>表示判断数组成员是否符合某种条件。</strong></p></blockquote><p>它们接受一个<strong>函数作为参数</strong>，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p><p><code>some</code>方法是**只要一个成员的返回值是<code>true</code><strong>，则</strong>整个<code>some</code>方法的返回值就是<code>true</code>**，否则返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem &gt;= <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>every</code>方法**是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>**，否则返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem &gt;= <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> &#125;<br><br>[].some(isEven) <span class="hljs-comment">// false</span><br>[].every(isEven) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p><h5 id="3-14-reduce-，reduceRight"><a href="#3-14-reduce-，reduceRight" class="headerlink" title="3.14 reduce()，reduceRight()"></a>3.14 reduce()，reduceRight()</h5><p><code>reduce()</code>方法和<code>reduceRight()</code>方法依次处理数组的每个成员，<strong>最终累计为一个值</strong>。它们的差别是，<code>reduce()</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight()</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p><blockquote><p><code>reduce()</code>方法和<code>reduceRight()</code>方法的<strong>第一个参数都是一个函数</strong>。<strong>该函数接受以下四个参数。</strong></p></blockquote><ol><li><strong>累积变量</strong>。第一次执行时，默认为数组的第一个成员；以后每次执行时，都是上一轮的返回值。</li><li><strong>当前变量</strong>。第一次执行时，默认为数组的第二个成员；以后每次执行时，都是下一个成员。</li><li>当前位置。一个整数，表示第二个参数（当前变量）的位置，默认为<code>1</code>。</li><li>原数组。</li></ol><p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  a,   <span class="hljs-comment">// 累积变量，必须</span></span></span><br><span class="hljs-params"><span class="hljs-function">  b,   <span class="hljs-comment">// 当前变量，必须</span></span></span><br><span class="hljs-params"><span class="hljs-function">  i,   <span class="hljs-comment">// 当前位置，可选</span></span></span><br><span class="hljs-params"><span class="hljs-function">  arr  <span class="hljs-comment">// 原数组，可选</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// ... ...</span><br></code></pre></td></tr></table></figure><p>如果要<strong>对累积变量指定初值，可以把它放在<code>reduce()</code>方法和<code>reduceRight()</code>方法的第二个参数。</strong></p><p><strong>建议总是加上第二个参数</strong>，这样比较符合直觉，每个数组成员都会依次执行<code>reduce()</code>方法的参数函数。另外，第二个参数可以防止空数组报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, b);<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;)<br><span class="hljs-comment">// 1 2</span><br><span class="hljs-comment">// 3 3</span><br><span class="hljs-comment">// 6 4</span><br><span class="hljs-comment">// 10 5</span><br><span class="hljs-comment">//最后结果：15</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>reduce()</code>方法用来求出数组所有成员的和。<code>reduce()</code>的参数是一个函数，数组每个成员都会依次执行这个函数。如果数组有 n 个成员，这个参数函数就会执行 n - 1 次。</p><ul><li>第一次执行：<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。</li><li>第二次执行：<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。</li><li>第三次执行：<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。</li><li>第四次执行：<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</li></ul><p>由于这两个方法<strong>会遍历数组</strong>，所以实际上可以用来做一些遍历相关的操作。比如，<strong>找出字符长度最长的数组成员。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLongest</span>(<span class="hljs-params">entries</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> entries.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">longest, entry</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> entry.length &gt; longest.length ? entry : longest;<br>  &#125;, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><br>findLongest([<span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]) <span class="hljs-comment">// &quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><h5 id="3-15-indexOf-，lastIndexOf"><a href="#3-15-indexOf-，lastIndexOf" class="headerlink" title="3.15 indexOf()，lastIndexOf()"></a>3.15 indexOf()，lastIndexOf()</h5><p><code>indexOf</code>方法返回<strong>指定元素</strong>在数组中<strong>第一次出现的索引（位置）</strong>，如果**没有出现则返回<code>-1</code>**。</p><p><code>indexOf</code>方法<strong>还可以接受第二个参数，表示搜索的开始位置。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].indexOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</p><p>注意，这两个方法<strong>不能用来搜索<code>NaN</code>的位置</strong>，即它们无法确定数组成员是否包含<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br>[<span class="hljs-literal">NaN</span>].lastIndexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>这是因为这两个方法内部，<strong>使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值。</strong></p><h5 id="3-16-链式使用"><a href="#3-16-链式使用" class="headerlink" title="3.16 链式使用"></a>3.16 链式使用</h5><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> users = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;tom@example.com&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;peter&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;peter@example.com&#x27;</span>&#125;<br>];<br><br>users<br>.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> user.email;<br>&#125;)<br>.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">email</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^t/</span>.test(email);<br>&#125;)<br>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">email</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(email);<br>&#125;);<br><span class="hljs-comment">// &quot;tom@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址，最后将它打印出来。</p><h4 id="2-4-包装对象"><a href="#2-4-包装对象" class="headerlink" title="2.4 包装对象"></a>2.4 包装对象</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会<strong>自动转为对象</strong>，也就是<strong>原始类型的“包装对象”（wrapper）</strong>。</p><p>所谓“包装对象”，指的是与<strong>数值、字符串、布尔值</strong>分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个<strong>原生对象</strong>。这三个<strong>原生对象可以把原始类型的值变成（包装成）对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);<br><span class="hljs-keyword">var</span> v2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><span class="hljs-keyword">var</span> v3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">typeof</span> v1 <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> v2 <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> v3 <span class="hljs-comment">// &quot;object&quot;</span><br><br>v1 === <span class="hljs-number">123</span> <span class="hljs-comment">// false</span><br>v2 === <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// false</span><br>v3 === <span class="hljs-literal">true</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><blockquote><p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个<strong>通用的数据模型</strong>，其次是使得原始类型的值也有办法调用自己的方法。</p></blockquote><h5 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h5><p>三种包装对象各自提供了许多实例方法，详见后文。这里介绍两种它们共同具有、从<code>Object</code>对象继承的方法：<code>valueOf()</code>和<code>toString()</code>。</p><h6 id="2-1-valueOf"><a href="#2-1-valueOf" class="headerlink" title="2.1 valueOf()"></a>2.1 valueOf()</h6><p><code>valueOf()</code>方法返回包装对象实例对应的<strong>原始类型的值</strong>。</p><h6 id="2-2-toString"><a href="#2-2-toString" class="headerlink" title="2.2 toString()"></a>2.2 toString()</h6><p><code>toString()</code>方法返回对应的字符串形式。</p><h5 id="3-原始类型与实例对象的自动转换"><a href="#3-原始类型与实例对象的自动转换" class="headerlink" title="3. 原始类型与实例对象的自动转换"></a>3. 原始类型与实例对象的自动转换</h5><p>某些场合，原始类型的值会<strong>自动当作包装对象调用</strong>，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</p><p>比如，字符串可以调用<code>length</code>属性，返回字符串的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>abc</code>是一个字符串，<strong>本身不是对象，不能调用<code>length</code>属性</strong>。JavaScript 引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。<strong>调用结束后，这个临时对象就会被销毁</strong>。这就叫原始类型与实例对象的自动转换。</p><p>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>s.x = <span class="hljs-number">123</span>;<br>s.x <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h5 id="4-自定义方法"><a href="#4-自定义方法" class="headerlink" title="4. 自定义方法"></a>4. 自定义方法</h5><p>除了原生的实例方法，包装对象还可以<strong>自定义方法和属性，供原始类型的值直接调用</strong>。</p><h4 id="2-5-Boolean对象"><a href="#2-5-Boolean对象" class="headerlink" title="2.5 Boolean对象"></a>2.5 Boolean对象</h4><h5 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>作为构造函数，它主要用于生成布尔值的<strong>包装对象实例</strong>。</p><p><code>false</code>对应的包装<strong>对象实例****，</strong>布尔运算结果也是<code>true</code>**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>).valueOf()) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// 无输出</span><br></code></pre></td></tr></table></figure><p>上面代码的第一个例子之所以得到<code>true</code>，是因为<code>false</code>对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值<code>true</code>（因为所有对象对应的布尔值都是<code>true</code>）。而实例的<code>valueOf</code>方法，则返回实例对应的原始值，本例为<code>false</code>。</p><h5 id="2-Boolean"><a href="#2-Boolean" class="headerlink" title="2. Boolean ()"></a>2. Boolean ()</h5><p>数据转换中已经叙述</p><h4 id="2-6-Number"><a href="#2-6-Number" class="headerlink" title="2.6 Number()"></a>2.6 Number()</h4><h5 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1.概述"></a>1.概述</h5><p><code>Number</code>对象是数值对应的包装对象，可以作为<strong>构造函数</strong>使用，也可以作为<strong>工具函数</strong>使用。</p><p>构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">typeof</span> n <span class="hljs-comment">// &quot;object</span><br></code></pre></td></tr></table></figure><p>工具函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h5 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2. 静态属性"></a>2. 静态属性</h5><p><code>Number</code>对象拥有以下一些静态属性（即<strong>直接定义在<code>Number</code>对象上的属性</strong>，而不是定义在实例上的属性）。</p><ul><li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>。</li><li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>。</li><li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>。</li><li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code>。</li><li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>。</li><li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Number</span>.POSITIVE_INFINITY <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">Number</span>.NEGATIVE_INFINITY <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">Number</span>.NaN <span class="hljs-comment">// NaN</span><br><br><span class="hljs-built_in">Number</span>.MAX_VALUE<br><span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-built_in">Number</span>.MAX_VALUE &lt; <span class="hljs-literal">Infinity</span><br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Number</span>.MIN_VALUE<br><span class="hljs-comment">// 5e-324</span><br><span class="hljs-built_in">Number</span>.MIN_VALUE &gt; <span class="hljs-number">0</span><br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER <span class="hljs-comment">// 9007199254740991</span><br><span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER <span class="hljs-comment">// -9007199254740991</span><br></code></pre></td></tr></table></figure><h5 id="3-实例方法-1"><a href="#3-实例方法-1" class="headerlink" title="3. 实例方法"></a>3. 实例方法</h5><p><code>Number</code>对象有4个实例方法，都跟将数值转<strong>换成指定格式</strong>有关。</p><h6 id="3-1-Number-prototype-toString"><a href="#3-1-Number-prototype-toString" class="headerlink" title="3.1 Number.prototype.toString()"></a>3.1 Number.prototype.toString()</h6><p><code>Number</code>对象部署了自己的<code>toString</code>方法，用来将一个数值转为字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">(<span class="hljs-number">10</span>).toString() <span class="hljs-comment">// &quot;10&quot;</span><br></code></pre></td></tr></table></figure><p><code>toString</code>方法<strong>可以接受一个参数，表示输出的进制</strong>。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">(<span class="hljs-number">10</span>).toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br>(<span class="hljs-number">10</span>).toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// &quot;12&quot;</span><br>(<span class="hljs-number">10</span>).toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，**<code>10</code>一定要放在括号里<strong>，这样表明后面的点表示调用对象属性。</strong>如果不加括号，这个点会被 JavaScript 引擎解释成小数点**，从而报错。</p><p>只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为<code>10</code>加上括号，还可以在<code>10</code>后面加两个点，JavaScript 会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性，从而得到正确结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-number">10.</span>.toString(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// &quot;1010&quot;</span><br><br><span class="hljs-comment">// 其他方法还包括</span><br><span class="hljs-number">10</span> .toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br><span class="hljs-number">10.0</span>.toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br></code></pre></td></tr></table></figure><p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-number">10.5</span>.toString() <span class="hljs-comment">// &quot;10.5&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010.1&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// &quot;12.4&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;a.8&quot;</span><br></code></pre></td></tr></table></figure><p>通过方括号运算符也可以调用<code>toString</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-number">10</span>[<span class="hljs-string">&#x27;toString&#x27;</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br></code></pre></td></tr></table></figure><p><code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法。</p><h6 id="3-2-Number-prototype-toFixed"><a href="#3-2-Number-prototype-toFixed" class="headerlink" title="3.2 Number.prototype.toFixed()"></a>3.2 Number.prototype.toFixed()</h6><p><code>toFixed()</code>方法先将一个数<strong>转为指定位数的小数</strong>，然后返回这个<strong>小数对应的字符串。</strong>        <code>toFixed()</code>方法的参数为小数位数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">(<span class="hljs-number">10</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;10.00&quot;</span><br><span class="hljs-number">10.005</span>.toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;10.01&quot;</span><br></code></pre></td></tr></table></figure><p>由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">(<span class="hljs-number">10.055</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 10.05</span><br>(<span class="hljs-number">10.005</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 10.01</span><br></code></pre></td></tr></table></figure><h6 id="3-3-Number-prototype-toExponential"><a href="#3-3-Number-prototype-toExponential" class="headerlink" title="3.3 Number.prototype.toExponential()"></a>3.3 Number.prototype.toExponential()</h6><p><code>toExponential</code>方法用于将一个数转为科学计数法形式，<strong>参数是小数点后有效数字的位数</strong>，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">(<span class="hljs-number">10</span>).toExponential()  <span class="hljs-comment">// &quot;1e+1&quot;</span><br>(<span class="hljs-number">10</span>).toExponential(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1.0e+1&quot;</span><br>(<span class="hljs-number">10</span>).toExponential(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1.00e+1&quot;</span><br><br>(<span class="hljs-number">1234</span>).toExponential()  <span class="hljs-comment">// &quot;1.234e+3&quot;</span><br>(<span class="hljs-number">1234</span>).toExponential(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1.2e+3&quot;</span><br>(<span class="hljs-number">1234</span>).toExponential(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1.23e+3&quot;</span><br></code></pre></td></tr></table></figure><h6 id="3-4-Number-prototype-toPrecision"><a href="#3-4-Number-prototype-toPrecision" class="headerlink" title="3.4 Number.prototype.toPrecision()"></a>3.4 Number.prototype.toPrecision()</h6><p><code>Number.prototype.toPrecision()</code>方法用于将一个<strong>数转为指定位数的有效数字</strong>。</p><p>该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p><h6 id="3-5-Number-prototype-toLocaleString"><a href="#3-5-Number-prototype-toLocaleString" class="headerlink" title="3.5 Number.prototype.toLocaleString()"></a>3.5 Number.prototype.toLocaleString()</h6><p><code>Number.prototype.toLocaleString()</code>方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。</p><h5 id="4-自定义方法-1"><a href="#4-自定义方法-1" class="headerlink" title="4. 自定义方法"></a>4. 自定义方法</h5><p>与其他对象一样，<code>Number.prototype</code>对象上面可以自定义方法，<strong>被<code>Number</code>的实例继承。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Number</span>.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> + x;<br>&#125;;<br><br><span class="hljs-number">8</span>[<span class="hljs-string">&#x27;add&#x27;</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>注意，数值的自定义方法，<strong>只能定义在它的原型对象<code>Number.prototype</code>上面</strong>，数值本身是无法自定义属性的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>n.x = <span class="hljs-number">1</span>;<br>n.x <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性<code>x</code>，不会报错，但毫无作用，总是返回<code>undefined</code>。这是因为一旦被调用属性，<code>n</code>就自动转为<code>Number</code>的实例对象，调用结束后，该对象自动销毁。所以，下一次调用<code>n</code>的属性时，实际取到的是另一个对象，属性<code>x</code>当然就读不出来。</p><h4 id="2-7-String-对象"><a href="#2-7-String-对象" class="headerlink" title="2.7 String()对象"></a>2.7 String()对象</h4><h5 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><code>String</code>对象是 JavaScript 原生提供的三个包装对象之一，用来生成<strong>字符串对象</strong>。</p><p>字符串对象是一个类似数组的对象（很像数组，但不是数组）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-comment">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>))[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>abc</code>对应的字符串对象，有数值键（<code>0</code>、<code>1</code>、<code>2</code>）和<code>length</code>属性，所以可以像数组那样取值。</p><h5 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h5><h6 id="2-1-String-fromCharCode"><a href="#2-1-String-fromCharCode" class="headerlink" title="2.1 String.fromCharCode()"></a>2.1 String.fromCharCode()</h6><p><code>String</code>对象提供的静态方法（即<strong>定义在对象本身，而不是定义在对象实例的方法</strong>），主要是<code>String.fromCharCode()</code>。该方法的参数是<strong>一个或多个数值，代表 Unicode 码点，</strong>返回值是这些<strong>码点组成的字符串</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">String</span>.fromCharCode() <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span>) <span class="hljs-comment">// &quot;a&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>)<br><span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>String.fromCharCode</code>方法的<strong>参数为空，就返回空字符串</strong>；否则，返回参数对应的 Unicode 字符串。</p><p>码点大于<code>0xFFFF</code>的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把<code>0x20BB7</code>拆成两个字符表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xD842</span>, <span class="hljs-number">0xDFB7</span>)<br><span class="hljs-comment">// &quot;𠮷&quot;</span><br></code></pre></td></tr></table></figure><h5 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3. 实例属性"></a>3. 实例属性</h5><h6 id="3-1-String-prototype-length"><a href="#3-1-String-prototype-length" class="headerlink" title="3.1 String.prototype.length"></a>3.1 String.prototype.length</h6><p>字符串实例的<code>length</code>属性返回字符串的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h5 id="4-实例方法"><a href="#4-实例方法" class="headerlink" title="4. 实例方法"></a>4. 实例方法</h5><h6 id="4-1-String-prototype-charAt"><a href="#4-1-String-prototype-charAt" class="headerlink" title="4.1 String.prototype.charAt()"></a>4.1 String.prototype.charAt()</h6><p><code>charAt</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置。</p><p>这个方法完全可以用数组下标替代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;abc&#x27;</span>.charAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;b&quot;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><p>如果参数为负数，或大于等于字符串的长度，<code>charAt</code><strong>返回空字符串</strong>。</p><h6 id="4-2-String-prototype-charCodeAt"><a href="#4-2-String-prototype-charCodeAt" class="headerlink" title="4.2 String.prototype.charCodeAt()"></a>4.2 String.prototype.charCodeAt()</h6><p><code>charCodeAt()</code>方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作。</p><p>如果没有任何参数，<code>charCodeAt</code>返回首字符的 Unicode 码点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt() <span class="hljs-comment">// 97</span><br></code></pre></td></tr></table></figure><p>如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code>。</p><p>注意，<code>charCodeAt</code>方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。</p><h6 id="4-3-String-prototype-concat"><a href="#4-3-String-prototype-concat" class="headerlink" title="4.3 String.prototype.concat()"></a>4.3 String.prototype.concat()</h6><p><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p><p>该方法可以接受多个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a&#x27;</span>.concat(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>如果参数不是字符串，<code>concat</code>方法会<strong>将其先转为字符串</strong>，然后再连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> one = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> two = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> three = <span class="hljs-string">&#x27;3&#x27;</span>;<br><br><span class="hljs-string">&#x27;&#x27;</span>.concat(one, two, three) <span class="hljs-comment">// &quot;123&quot;</span><br>one + two + three <span class="hljs-comment">// &quot;33&quot;</span><br></code></pre></td></tr></table></figure><h6 id="4-4-String-prototype-slice"><a href="#4-4-String-prototype-slice" class="headerlink" title="4.4 String.prototype.slice()"></a>4.4 String.prototype.slice()</h6><p><code>slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p><h6 id="4-5-String-prototype-substring"><a href="#4-5-String-prototype-substring" class="headerlink" title="4.5 String.prototype.substring()"></a>4.5 String.prototype.substring()</h6><p><code>substring</code>方法用于从原字符串<strong>取出子字符串</strong>并返回，不改变原字符串，跟<code>slice</code>方法很相像。</p><p>如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></td></tr></table></figure><p>如果参数是负数，<code>substring</code>方法会自动将负数转为0。</p><p>由于这些规则违反直觉，因此不建议使用<code>substring</code>方法，应该优先使用<code>slice</code>。</p><h6 id="4-6-String-prototype-substr"><a href="#4-6-String-prototype-substr" class="headerlink" title="4.6 String.prototype.substr()"></a>4.6 String.prototype.substr()</h6><p><code>substr</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>和<code>substring</code>方法的作用相同。</p><p><code>substr</code>方法的第一个参数是子字符串的开始位置（从0开始计算），<strong>第二个参数是子字符串的长度。</strong></p><h6 id="4-7-String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#4-7-String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="4.7 String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>4.7 String.prototype.indexOf()，String.prototype.lastIndexOf()</h6><p><code>indexOf</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// 4</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.indexOf(<span class="hljs-string">&#x27;script&#x27;</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p><code>indexOf</code>方法还可以<strong>接受第二个参数，表示从该位置开始向后匹配。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;hello world&#x27;</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><h6 id="4-8-String-prototype-trim"><a href="#4-8-String-prototype-trim" class="headerlink" title="4.8 String.prototype.trim()"></a>4.8 String.prototype.trim()</h6><p><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;  hello world  &#x27;</span>.trim()<br><span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>该方法去除的不仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;\r\nabc \t&#x27;</span>.trim() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><h6 id="4-9-String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#4-9-String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="4.9 String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>4.9 String.prototype.toLowerCase()，String.prototype.toUpperCase()</h6><p><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们<strong>都返回一个新字符串，不改变原字符串</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;Hello World&#x27;</span>.toLowerCase()<br><span class="hljs-comment">// &quot;hello world&quot;</span><br><br><span class="hljs-string">&#x27;Hello World&#x27;</span>.toUpperCase()<br><span class="hljs-comment">// &quot;HELLO WORLD&quot;</span><br></code></pre></td></tr></table></figure><h6 id="4-10-String-prototype-match"><a href="#4-10-String-prototype-match" class="headerlink" title="4.10 String.prototype.match()"></a>4.10 String.prototype.match()</h6><p><code>match</code>方法用于确定原字符串<strong>是否匹配某个子字符串</strong>，<strong>返回一个数组</strong>，成员为<strong>匹配的第一个字符串</strong>。如果没有找到匹配，则返回<code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-comment">// [&quot;at&quot;]</span><br><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;xt&#x27;</span>) <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p><strong>返回的数组还有<code>index</code>属性和<code>input</code>属性</strong>，分别表示匹配字符串开始的位置和<strong>原始字符串</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> matches = <span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;at&#x27;</span>);<br>matches.index <span class="hljs-comment">// 1</span><br>matches.input <span class="hljs-comment">// &quot;cat, bat, sat, fat&quot;</span><br></code></pre></td></tr></table></figure><h6 id="4-11-String-prototype-search-，String-prototype-replace"><a href="#4-11-String-prototype-search-，String-prototype-replace" class="headerlink" title="4.11 String.prototype.search()，String.prototype.replace()"></a>4.11 String.prototype.search()，String.prototype.replace()</h6><p><code>search</code>方法的用法基本等同于<code>match</code>，但是返回值为<strong>匹配的第一个位置</strong>。如果没有找到匹配，则返回<code>-1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.search(<span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p><code>replace</code>方法用于替换匹配的子字符串，<strong>一般情况下只替换第一个匹配</strong>（除非使用带有<code>g</code>修饰符的正则表达式）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;baa&quot;</span><br></code></pre></td></tr></table></figure><h6 id="4-12-String-prototype-split"><a href="#4-12-String-prototype-split" class="headerlink" title="4.12 String.prototype.split()"></a>4.12 String.prototype.split()</h6>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown写法</title>
    <link href="/2021/11/12/Markdown%E5%86%99%E6%B3%95/"/>
    <url>/2021/11/12/Markdown%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h1><h2 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sequence">李雷 -&gt; 韩梅梅: Hello 梅梅, How are you?<br>Note right of 韩梅梅: 韩梅梅心想<br>韩梅梅 --&gt; 李雷: I&#x27;m fine, thanks, and you?<br></code></pre></td></tr></table></figure><h2 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 闹钟响起<br>op=&gt;operation: 与床板分离<br>cond=&gt;condition: 分离成功?<br>e=&gt;end: 快乐的一天<br><br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br></code></pre></td></tr></table></figure><h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><pre><code class=" mermaid">gantt        dateFormat  YYYY-MM-DD        title 快乐的生活        section 吃一把鸡就学习        学习            :done,    des1, 2014-01-06,2014-01-09        疯狂学习               :active,  des2, 2014-01-09, 3d        继续疯狂学习               :         des3, after des2, 5d        吃鸡！               :         des4, after des3, 4d        section 具体内容        学习Python :crit, done, 2014-01-06,72h        学习C++          :crit, done, after des1, 2d        学习Lisp             :crit, active, 3d        学习图形学        :crit, 4d        跳伞           :2d        打枪                      :2d</code></pre><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li><p>加粗： <code>Ctrl + B</code></p></li><li><p>撤销： <code>Ctrl + Z</code></p></li><li><p>字体倾斜 ：<code>Ctrl+I</code></p></li><li><p>下划线：<code>Ctrl+U</code></p></li><li><p>多级标题： <code>Ctrl + 1~6</code></p></li><li><p>有序列表：<code>Ctrl + Shift + [</code></p></li><li><p>无序列表：<code>Ctrl + Shift + ]</code></p></li><li><p>降级快捷键 ：<code>Tab</code></p></li><li><p>升级快捷键：<code>Shift + Tab</code></p></li><li><p>插入链接： <code>Ctrl + K</code></p></li><li><p>插入公式： <code>Ctrl + Shift + M</code></p></li><li><p>行内代码： <code>Ctrl + Shift + K</code></p></li><li><p>插入图片： <code>Ctrl + Shift + I</code></p></li><li><p>返回Typora顶部：<code>Ctrl+Home</code></p></li><li><p>返回Typora底部 ：<code>Ctrl+End</code></p></li><li><p>创建表格 ：<code>Ctrl+T</code></p></li><li><p>选中某句话 ：<code>Ctrl+L</code></p></li><li><p>选中某个单词 ：<code>Ctrl+D</code></p></li><li><p>选中相同格式的文字 ：<code>Ctrl+E</code></p></li><li><p>搜索: <code>Ctrl+F</code></p></li><li><p>搜索并替换 ：<code>Ctrl+H</code></p></li><li><p>删除线 ：<code>Alt+Shift+5</code></p></li><li><p>引用 ：<code>Ctrl+Shift+Q</code></p></li><li><p>生成目录：<code>[TOC]+Enter</code></p><p>注：一些实体符号需要在实体符号之前加” \ ”才能够显示</p></li></ul><p>作者：徐太尉<br>链接：<a href="https://zhuanlan.zhihu.com/p/293557841">https://zhuanlan.zhihu.com/p/293557841</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="区域元素"><a href="#区域元素" class="headerlink" title="区域元素"></a>区域元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">YAML FONT Matters<br></code></pre></td></tr></table></figure><p>在文章的最上方输入—，按换行键产生，然后在里面输入内容即可。</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>按换行键[Enter]建立新的一行,按<code>Shift</code>+<code>Enter</code>可以创建一个比段落间距更小的行间距。可在行尾插入打断线，禁止向后插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">打断线&lt;br/&gt;后面的内容将自动换行<br></code></pre></td></tr></table></figure><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>开头#的个数表示，空格+文字。标题有1~6个级别，#表示开始，按换行键结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"># 一级标题 快捷键为 Ctrl + 1<br>## 二级标题 快捷键为 Ctrl + 2<br>......<br>###### 六级标题 快捷键为 Ctrl + 6<br></code></pre></td></tr></table></figure><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>斜体以**或__括住</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">*这是斜体字体1*_这是斜体字体2_<br></code></pre></td></tr></table></figure><p><em>这是斜体字体1</em><br><em>这是斜体字体2</em></p><p>加粗<br>开头<code>**</code>，结尾<code>**</code>。<br>或者开头<code>__</code>,结尾<code>__</code>(两个短横线)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">**这是加粗字体1** __这是加粗字体2__<br></code></pre></td></tr></table></figure><p>这是加粗字体1<br>这是加粗字体2</p><p>删除线<br>开头<code>~~</code>，结尾<code>~~</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">~~这是错误文字~~<br></code></pre></td></tr></table></figure><p>这是错误文字</p><p>下划线使用HTML标签<u>下划线</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;u&gt;下划线&lt;/u&gt;<br></code></pre></td></tr></table></figure><p>下划线</p><p>高亮<br><code>==内容==</code>，需要自己在偏好设置里面打开这项功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">==高亮==<br>高亮<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>行内输入代码块快捷键： <code>Ctrl + Shift + K</code></p><ol><li>开头```+语言名，开启代码块，换行键换行，光标下移键跳出<br>示例：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">print(&quot;hello,python!&quot;&quot;)<br></code></pre></td></tr></table></figure><ol><li>用两个`在正常段落中表示代码<br>例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Use the `printf()`function.<br></code></pre></td></tr></table></figure><p>Use the <code>printf()</code>function.</p><h3 id="数学式"><a href="#数学式" class="headerlink" title="数学式"></a>数学式</h3><p>打开Typora选择数学模块</p><ul><li>点击“段落”—&gt;“公式块”</li><li>快捷键Ctrl+Shift+m</li><li><code>“$$”+回车</code></li></ul><p>以上三种方式都能打开数学公式的编辑栏。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入$，然后按ESC键，之后输入Tex命令，可预览<br>例如：<br>$\lim_&#123;x\to\infty&#125;\exp(-x)=0$<br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/v2-c0139796d5848b706c9f2f4d79c7a749_b.png" alt="img"></p><p>下标使用~~括住内容。需要自己在偏好设置里面打开这项功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">H~2~O<br></code></pre></td></tr></table></figure><p>H2O</p><p>上标</p><p>使用^括住内容。需要自己在偏好设置里面打开这项功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">y^2^=4<br></code></pre></td></tr></table></figure><p>y2=4</p><h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p>Typora语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">以:开始，然后输入表情的英文单词,以：结尾，将直接输入该表情.例如：<br>:smile<br>:cry<br>:happy<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>开头|+列名+|+列名+|+换行键，创建一个2*2表格，<code>Ctrl+Enter</code>可建立新行。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">|第一列|第二列|<br></code></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>输入 <code>***</code> 或者 <code>---</code>,按换行键换行，即可绘制一条水平线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">***---<br></code></pre></td></tr></table></figure><hr><p>上下是水平线</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>开头&gt;表示，空格+文字，按换行键换行，双按换行跳出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; 引注1<br>&gt; ···<br>&gt; 引注2<br>&gt;还有一行，双按换行键跳出引注模式<br></code></pre></td></tr></table></figure><p>示例：</p><blockquote><p>引注1<br>···<br>引注2还有一行，双按换行键跳出引注模式</p></blockquote><p>普通引用</p><blockquote><p>空格 + 引用文字：在引用的文字前加&gt;+空格即可，引用可以嵌套。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; 引用文本前使用 [大于号+空格]<br>&gt; 这行可以不加，新起一行都要加上哦<br>&gt;这是引用的内容<br>&gt;&gt;这是引用的内容<br></code></pre></td></tr></table></figure><p>示例：</p><blockquote><p>引用文本前使用 [大于号+空格]这行可以不加，新起一行都要加上哦<br>这是引用的内容<br>这是引用的内容</p></blockquote><p>列表中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">* 第一项   <br>&gt; 引用1    <br>&gt; 引用2<br>* 第二项<br></code></pre></td></tr></table></figure><p>示例：</p><ul><li>第一项</li></ul><blockquote><p>引用1引用2</p></blockquote><ul><li>第二项</li></ul><p>引用里嵌套引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; 最外层引用<br>&gt; &gt; 多一个 <br>&gt; 嵌套一层引用<br>&gt; &gt; &gt; 可以嵌套很多层<br></code></pre></td></tr></table></figure><p>引用里嵌套列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; - 这是引用里嵌套的一个列表<br>&gt; - 还可以有子列表<br>&gt;     * 子列表需要从 - 之后延后四个空格开始<br></code></pre></td></tr></table></figure><p>引用里嵌套代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt;     同样的，在前面加四个空格形成代码块<br></code></pre></td></tr></table></figure><blockquote><p>或者使用 ``` 形成代码块</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 脚注</span><br><span class="hljs-string"></span><br><span class="hljs-string">在需要添加脚注的文字后面+[+^+序列+]，注释的产生可以鼠标放置其上单击自动产生，添加信息</span><br><span class="hljs-string"></span><br><span class="hljs-string">或人工添加+[+^+序列+]+:</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>text<br>脚注产生的方法[^footnote].<br>[^footnote]:这个就是<span class="hljs-string">&quot;脚注&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p>脚注的产生方法[1]</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接<br>输入网址，单击链接，展开后可编辑<br>ctr+单击，打开链接<br>例如：<a href="https://link.zhihu.com/?target=https://www.baidu.com">https://www.baidu.com</a></p><p>常用链接方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">文字链接 [链接名称](http://链接网址)网址链接 &lt;http://链接网址&gt;<br></code></pre></td></tr></table></figure><p>示例效果：百度</p><p>超链接</p><p>格式1：用[ ]括住要超链接的内容，紧接着用( )括住超链接源+名字，超链接源后面+超链接命名<br>同样ctrl+单击，打开链接例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这是[百度](https://www.baidu.com)官网<br></code></pre></td></tr></table></figure><p>这是 百度官网格式2：超链接 title可加可不加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">This is [an example](http://example.com/ &quot;Title&quot;) inline link.<br>[This link](http://example.net/) has no title attribute.<br></code></pre></td></tr></table></figure><p>This is an example inline link.This link has no title attribute.</p><p>高级链接技巧</p><p>使用[+超链接文字+]+[+标签+]，创建可定义链接<br>ctrl+单击，打开链接。示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这是[百度][id][id]:https://www.baidu.com<br></code></pre></td></tr></table></figure><p>这是百度示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">这个链接用 1 作为网址变量 [Google][1].<br>这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].<br>然后在文档的结尾为变量赋值（网址）  <br>[1]: http://www.google.com/  <br>[yahoo]: http://www.yahoo.com/<br></code></pre></td></tr></table></figure><h3 id="URLs"><a href="#URLs" class="headerlink" title="URLs"></a>URLs</h3><p>用&lt;&gt;括住url，可手动设置url对于标准URLs，可自动识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;www.baidu.com&gt;<br></code></pre></td></tr></table></figure><p>&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a></p><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>开头*/+/- 加空格+文字，可以创建无序序列，换行键换行，删除键+shift+tab跳出<br>开头1.加空格+后接文字，可以创建有序序列例：</p><ul><li>第一个无序序列</li><li>第二个无序序列</li><li>······</li></ul><ol><li>第一个有序序列</li><li>第二个有序序列</li><li>······</li></ol><p>可选序列</p><p>开头序列+空格+[ ]+空格+文字，换行键换行，删除键+shift+tab跳出例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">- [ ] 第一个可选序列<br>- [ ] 第二个可选序列<br>- [ ] 第三个可选序列<br>- [x] 第四个可选序列<br></code></pre></td></tr></table></figure><ul><li>第一个可选序列</li><li>第二个可选序列</li><li>第三个可选序列</li><li>第四个可选序列<br>总结：先输入减号，然后输入空格，之后就变成了黑色圆点，在输入[]，在中间加个空格，回车就可以注：任务列表无快捷键，可以点击菜单栏段落，任务列表。</li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><blockquote><p>Typora文本文档中有使用图片内容，如果需要发布在各个兼容Markdown的软件平台，需要预先上传文档中的图片至图床，再通过对图床的图片链接调用，才能正常显示，否则各个平台将无法看到该文档图片。<br>免费图床网址：<a href="https://link.zhihu.com/?target=https://sm.ms/">https://sm.ms/</a>图床设置：[Typora图床自动上传图片设置篇]</p></blockquote><ol><li>手动添加：跟链接的方法区别在于前面加了个感叹号 <code>!</code>，这样是不是觉得好记多了呢？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">![图片名称](http://图片网址)<br></code></pre></td></tr></table></figure><ol><li>当然，你也可以像网址那样对图片网址使用变量</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">这个链接用 1 作为网址变量 [Google][1].<br>然后在文档的结尾位变量赋值（网址） <br><br>[1]: http://www.google.com/logo.png<br></code></pre></td></tr></table></figure><ol><li>除了以上2种方式之外，还可以直接将图片拖拽进来，自动生成链接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">![显示的文字](C:\Users\Hider\Desktop\echart.png &quot;图片标题&quot;)<br>![显示的文字](C:\Users\Hider\Desktop\echart.png)<br></code></pre></td></tr></table></figure><h2 id="二、Typora图床设置篇章"><a href="#二、Typora图床设置篇章" class="headerlink" title="二、Typora图床设置篇章"></a>二、Typora图床设置篇章</h2><p>Typora文本文档中有使用图片内容，如果需要发布在各个兼容Markdown的软件平台，需要预先上传文档中的图片至图床，再通过对图床的图片链接调用，才能正常显示，否则各个平台将无法看到该文档图片。</p><blockquote><p>图床意义：就是专门用来存放图片，同时允许你把图片对外连接的网上空间，不少图床都是免费的。</p></blockquote><p>图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具。</p><p>Typora文件偏好属性&gt;上传服务设定&gt;选择PicGo-Core（command line&gt;选择下载更新如图一</p><p><img src="https://pic1.zhimg.com/v2-c94e3203acb34c2248b4b4cc36cfda8c_b.jpg" alt="img">图一</p><p>图二为更新下载完成状态</p><p><img src="https://pic2.zhimg.com/v2-65389866fb0aae9443c3e8787c8666d5_b.jpg" alt="img">图二</p><p>图三打开配置文件后的文件config.json</p><p><img src="https://pic4.zhimg.com/v2-613d1e6d34d329ce61c687d272d5d203_b.jpg" alt="img">图三</p><p>图四为图床网站，自己注册新的账号</p><p><img src="https://pic2.zhimg.com/v2-cc8839b95d32fc2aa034b93355fe9f41_b.jpg" alt="img">图四</p><p>如图图五找到账号中相应的token，若没有，生成即可</p><p><img src="https://pic2.zhimg.com/v2-e9f78eee9697588f06b6018b7172df79_b.jpg" alt="img">图五</p><p>按照图六格式添加相应的内容代码后保存</p><p><img src="https://pic1.zhimg.com/v2-1b80c13d0095786732be0d9f0fc15be0_b.jpg" alt="img">图六</p><p>回到偏好设置如图一中的验证图片上传选项功能，若出现图七提示，说明，图床自动上传功能设置成功。</p><p><img src="https://pic3.zhimg.com/v2-5cd68ecdd2e4471a9d2a0ba40233d65e_b.jpg" alt="img">图七</p><ol><li>这个就是脚注 ↩</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于如何快速阅读和整理文献的相关经验</title>
    <link href="/2021/11/12/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E5%92%8C%E6%95%B4%E7%90%86%E6%96%87%E7%8C%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E9%AA%8C%E3%80%82/"/>
    <url>/2021/11/12/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E5%92%8C%E6%95%B4%E7%90%86%E6%96%87%E7%8C%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E9%AA%8C%E3%80%82/</url>
    
    <content type="html"><![CDATA[<h1 id="李沐大神分享关于如何快速阅读和整理文献的相关经验"><a href="#李沐大神分享关于如何快速阅读和整理文献的相关经验" class="headerlink" title="李沐大神分享关于如何快速阅读和整理文献的相关经验"></a>李沐大神分享关于如何快速阅读和整理文献的相关经验</h1><p>本文整理自 B 站视频：<a href="https://www.bilibili.com/video/BV1nA41157y4">https://www.bilibili.com/video/BV1nA41157y4</a></p><h2 id="本文的主要内容包括："><a href="#本文的主要内容包括：" class="headerlink" title="本文的主要内容包括："></a>本文的主要内容包括：</h2><h3 id="1、读文献的目的"><a href="#1、读文献的目的" class="headerlink" title="1、读文献的目的"></a>1、读文献的目的</h3><h3 id="2、整理论文的技巧和工具"><a href="#2、整理论文的技巧和工具" class="headerlink" title="2、整理论文的技巧和工具"></a>2、整理论文的技巧和工具</h3><h3 id="3、工具相关的教程"><a href="#3、工具相关的教程" class="headerlink" title="3、工具相关的教程"></a>3、工具相关的教程</h3><p>这里我做了相关的总结和规划，并收集了一些相关工具的教程。如果对你有所帮助，也欢迎给我三连，让我知道这些对我们都很重要！</p><p>以后看到一些优质的内容，我也会努力分享给大家，无论大家是在科研或者工作中，希望都能有所收获。</p><h4 id="一、明确你读文献的目的是什么"><a href="#一、明确你读文献的目的是什么" class="headerlink" title="一、明确你读文献的目的是什么"></a>一、明确你读文献的目的是什么</h4><p>不同阶段的目的是不同的</p><p>1）在学生时代，读论文的主要的目的是对一两个我的研究方向了如指掌，包括了对最重要的论文反复研读，了解其中每一句话在说什么，并且能够重复他们的实验</p><p>2）在工作之后，目的是对 5-10 个我比较感兴趣的研究方向了解他们的最新的进展，这样子我能够去思考我们团队接下来的研究方向，以及在技术讨论的时候，我能给大家指出这是一篇相关的论文，大家可以去看一下</p><h4 id="二、整理论文的技巧和工具"><a href="#二、整理论文的技巧和工具" class="headerlink" title="二、整理论文的技巧和工具"></a>二、整理论文的技巧和工具</h4><p>把一个领域里面我想读的论文放在一个markdown文件里面（这里推荐可以使用typora软件，支持不同系统），同时也把我的笔记放在这个里面。我用 markdown 的原因主要是因为它简单、便携性、而且软件支持也不错（例如支持latax-公式、mermaid-流程图 等等），不需要用特别复杂的文献管理软件</p><p>举个例子：</p><p>这个是我在几个月前读video相关的文献（如下图所示），做了一个笔记，可以看到这个 markdown 文件里面就是一个列表，每一项就是一篇论文，每一项的第一行是他的论文的标题、作者发表的地方、年份以及一些链接包括了本地下载好的pdf的链接、最后是它的引用数</p><p>我们知道引用数还在很大程度上反映了一篇论文的重要程度 特别是对一个新的领域我们不熟悉的话，引用数是一个判断这篇论文是不是值得现在读的一个很好的标准</p><p>通常来说是比较简单 可能就几句话的样子，也可能会包括了一些重要的图重要的公式在这里面markdown对 latax支持比较好而且对插图也有一定的支持。如果我们想插入一篇新的想读短论文的话 我们就把它的链接放在最后就行了</p><p>这里大佬自己写了一个小软件能够检测哪个 markdown文件被修改，并把里面插入在 url 里面的论文下载下来，并且将它的论文的标题，作者以及引用数全部自动生成好。（未分享出来）</p><p>小技巧：</p><p>有时候一个领域里面的重要论文比较多的时候，我也会去画一个图，把比较重要的论文之间相互联系起来</p><p>我们用的是 mermaid 的这个脚本语言 ，它能够很方便的插入一些连接图 这个是它的源代码 它嵌入在markdown里面 可以自动生成出下面这张图出来。</p><p>这里面一个方块就是一篇论文 一个箭头表示是下面一个论文是如何改进上面一个论文的 并且有一点简简单单的注释。</p><p>最后 我一般需要平板来读论文 我用的是12 9寸的ipad 这样子能够尽量的跟一个论文打印的纸张的大小差不多，什么文档文件 以及下载好的pdf都会被同步到dropbox里面，我们在 ipad 直接打开，不仅能够看我的笔记 而且能够直接点击pdf的链接，打开pdf在ipad上直接阅读。</p><h4 id="三、工具的整理和相关的入门教程"><a href="#三、工具的整理和相关的入门教程" class="headerlink" title="三、工具的整理和相关的入门教程"></a>三、工具的整理和相关的入门教程</h4><p>上面的内容就是李沐大神的分享，下面是我针对视频中提到的一些工具，进行相应的整理。</p><h5 id="1、markdown工具选择"><a href="#1、markdown工具选择" class="headerlink" title="1、markdown工具选择"></a>1、markdown工具选择</h5><p>这里推荐 typora ，官网：<a href="https://www.typora.io/">https://www.typora.io/</a></p><p>根据自己的电脑系统选择合适的软件</p><p><a href="https://sspai.com/post/54912">https://sspai.com/post/54912</a> （含大量操作的动画）</p><h5 id="3、typora-中-mermaid-教程"><a href="#3、typora-中-mermaid-教程" class="headerlink" title="3、typora 中 mermaid 教程"></a>3、typora 中 mermaid 教程</h5><p><a href="https://www.runoob.com/note/47651">https://www.runoob.com/note/47651</a></p><p>我稍微试了一下</p>]]></content>
    
    
    
    <tags>
      
      <tag>Typora，论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2021/11/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/11/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是机器学习"><a href="#1-什么是机器学习" class="headerlink" title="1.什么是机器学习"></a>1.什么是机器学习</h1><h2 id="机器学习阐述"><a href="#机器学习阐述" class="headerlink" title="机器学习阐述"></a>机器学习阐述</h2><p>机器学习是很多种<strong>方法和模型</strong>的总称。<br>        <strong>神经网络是一种机器学习模型</strong>，可以说是目前最火的一种。<br>        深度神经网络就是层数比较多的神经网络。<br>        深度学习就是使用了<strong>深度神经网络</strong>的机器学习。</p><blockquote><p>机器学习算法是人工智能技术的主要算法之一，根据学习方法可以将其分为传统机器学习和深度学习（人工智能标准化白皮书2019）。传6地球物理学进展统的机器学习算法有逻辑回归、朴素贝叶斯、支持向量机、随机森林、决策树、人工神经网络等，需要人工提取特征。深度学习是机器学习领域的最新分支研究，是基于深度神经网络的学习，能够自动提取特征，具体算法包括卷积神经网络、循环神经网络、递归神经网络、深度玻尔兹曼机、深度置信网络等（唐伟等，2019）。</p><p>Ｈｉｎｔｏｎ ａｎｄ Ｓａｌａｋｈｕｔｄｉｎｏｖ（２００６）提出“深度学习（ｄｅｅｐ ｌｅａｒｎｉｎｇ）”的概念，证明了深层神经网络的可训练性，展现了深层神经网络更强大的特征提取和非线性拟合能力。</p></blockquote><p>机器学习(MachineLearning，ML)是一门多领域的交叉学科，涉及概率论、统计学、线性代数、算法等多门学科。它专门研究计算机如何<strong>模拟和学习人的行为</strong>，以获取新的知识或技能，<strong>重新组织已有的知识结构</strong>使之不断完善自身的性能。</p><p>机器学习已经有了十分广泛的应用，例如：数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用。</p><p>机器学习的算法分为两大类：监督学习和无监督学习。</p><p>监督学习即在机器学习过程中提供对错指示。一般是在数据组中包含最终结果(0，1)，通过算法让机器自己减少误差。这一类学习主要应用于分类和预测(Regression&amp;Classify)。监督学习从给定的训练数据集中学习出一个目标函数，<strong>当新的数据到来时，可以根据这个函数预测结果</strong>。监督学习的训练集要求包括输入和输出，也可以说包括特征和目标，训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类。</p><p>非监督学习又称归纳性学习(Clustering)，利用K方式(KMean)建立中心(Centriole)，通过循环和递减运算(Iteration&amp;Descent)来减小误差，达到分类的目的。</p><h2 id="利用机器学习的预测模型来解决问题共有六个基本步骤"><a href="#利用机器学习的预测模型来解决问题共有六个基本步骤" class="headerlink" title="利用机器学习的预测模型来解决问题共有六个基本步骤"></a>利用机器学习的预测模型来解决问题共有六个基本步骤</h2><p>·定义问题：研究和提炼问题的特征，以帮助我们更好地理解项目的目标。</p><p>·数据理解：通过描述性统计和可视化来分析现有的数据。</p><p>·数据准备：对数据进行格式化，以便于构建一个预测模型。</p><p>·评估算法：通过一定的方法分离一部分数据，用来评估算法模型，并选取一部分代表数据进行分析，以改善模型。</p><p>·优化模型：通过调参和集成算法提升预测结果的准确度。</p><p>·结果部署：完成模型，并执行模型来预测结果和展示。</p><h1 id="2-优势"><a href="#2-优势" class="headerlink" title="2.优势"></a>2.优势</h1><h2 id="传统检测强对流"><a href="#传统检测强对流" class="headerlink" title="传统检测强对流"></a>传统检测强对流</h2><p>强对流监测预报，目前仍大量依靠传统的统计结果和预报员经验。长期的应用结果表明，以上方法具有较大的局限性。首先，不同季节、不同地势分布、不同气候背景区域之间，强对流天气发生发展条件与特征阈值范围必然会存在差异，难以使用一套统一的特征物理量阈值组合来实现不同区域的分类强对流天气的预报（王婷波等，2020）；其次，天气预报过程中需要使用大量数据，依靠预报员统计或者主观提取特征物理量和阈值范围，难以完全发现数据中有价值的细节信息或者细微差别，特别是一些中小尺度信息；再次，强对流天气复杂多变，如果预报员对于强对流发生发展规律认识不够深刻、全面，也会忽视其中的有效信息。传统基于物理机理的统计模型等客观方法，由于基于主观认识建立，也难以避免地存在上述问题。近年来，以深度学习为代表的机器学习算法的兴起，有效结合各类气象大数据，已经成为强对流天气预报的有效手段（McGovern et al,2017;Reichstein et al,2019）。与浅层神经网络、支持向量机等传统机器学习算法相比，深度神经网络不仅能够为复杂非线性系统提供建模，更能够为模型提供更高的抽象层次，从而提高模型的特征提取能力；其优势在于能以更加紧凑简洁的方式来表达比浅层网络大得多的函数集合，并在图像识别、语音处理等领域相比传统方法的性能有了显著提升（Ｋｒｉｚｈｅｖｓｋｙｅｔａｌ，２０１２ＬｅＣｕｎａｎｄＢｅｎｇｉｏ，１９９5；Ｓｚｅｇｅｄｙｅｔａｌ，２０１３）。</p><h2 id="机器学习检测"><a href="#机器学习检测" class="headerlink" title="机器学习检测"></a>机器学习检测</h2><p>机器学习算法，特别是深度学习，需要大量的历史数据进行建模并训练，从而从历史数据中学习到规律。天气预报，经过长时间的发展，积累了海量历史观测数据、数值预报模式数据，具备“大数据”属性，能够为机器学习提供训练所需的大量数据，因此，一直以来，机器学习在天气预报领域有众多成功应用（karpatneetal，2019）。</p><h1 id="3-机器学习在气象领域的应用"><a href="#3-机器学习在气象领域的应用" class="headerlink" title="3.机器学习在气象领域的应用"></a>3.机器学习在气象领域的应用</h1><p>以深度学习为代表的机器学习算法取得突破性进展，并且在气象领域的应用范围更加广泛，基本覆盖了<strong>观测、预报、服务</strong>等所有气象业务</p><h2 id="识别窄带弱回波"><a href="#识别窄带弱回波" class="headerlink" title="识别窄带弱回波"></a>识别窄带弱回波</h2><p>徐月飞（2020）等通过雷达回波绕雷达中心旋转不变性以及所有不同走向的窄带弱回波都能在某个旋转角度转化为垂直走向这两大特点，基于FasterRCNN和Incep⁃tionV2，提出了改进的深度卷积网络阵风锋识别算法(d-NNGFDA)，将已有数据进行360°每间隔10°进行旋转，并且只对垂直走向的窄带弱回波进行标记，实现了数据量的扩充，降低了窄带雷达回波的识别复杂度。</p><h2 id="识别强对流、雷暴"><a href="#识别强对流、雷暴" class="headerlink" title="识别强对流、雷暴"></a>识别强对流、雷暴</h2><h3 id="对流天气预报"><a href="#对流天气预报" class="headerlink" title="对流天气预报"></a>对流天气预报</h3><h4 id="对流天气预报的深度网络模型"><a href="#对流天气预报的深度网络模型" class="headerlink" title="对流天气预报的深度网络模型"></a>对流天气预报的深度网络模型</h4><p>目前应用到对流天气预报的深度网络模型包括三种：一种是卷积神经网络，通过将输入的格点天气要素看成是图像的形式，通过图像滤波器进行特征学习，充分考虑到空间结构的相关，但缺点是缺乏处理序列数据的能力，只适合处理“定长”数据。另一种是循环神经网络，这种经常应用于自然语言处理的模型通过一种自回归结构，能够灵活地处理序列数据，在时间维度上进行有效的学习，缺点也较为明显，和多层感知机一样，只能把输入特征用一维的向量进行表征，这样就丢失了格点数据固有的空间特征，学习能力较弱。最后一种是将上述两种模型进行不同形式的结合，能同时学习到空间和时间的特征，更加适合解决对流天气预测的问题，卷积长短期记忆单元模型和本研究的卷积GRU模型均属于这一类网络。</p><h4 id="对流天气预报方法"><a href="#对流天气预报方法" class="headerlink" title="对流天气预报方法"></a>对流天气预报方法</h4><p>目前使用广泛的对流天气预报方法是基于雷达回波的外推技术和数值天气预报模式，但是这两种方法均存在不足之处（周康辉等，2021）。总的来说，雷达回波外推在临近预报方面还是存在一定缺陷。数值天气预报是指根据大气实际情况，在一定的初始和边界条件下，通过大型计算机做数值计算，求解描述天气演变过程的流体力学和热力学方程组，预测未来一定时段的大气运动状态和天气现象的方法。数值预报虽然已经在气象领域得到广泛应，但也有其自身的局限性（Ｗｅｉｓｍａｎ，ｅｔ　ａｌ，２０１０）。特别是在临近预报应用方面准确率低，不够成熟，且需要复杂的物理方程计算，在精细化预测上难以满足准确性和实时性的需求</p><p>近年来，气象研究人员尝试使用深度学习方法来进行强对流临近预报。Pulukool等（2020）基于自动编码器和卷积神经网络分别构建了两种深度学习冰雹预报模型，采用TRMM卫星资料和CMWF再分析资料，利用对流位能、对流抑制能、1-3km风切变和暖云区厚度4个气象因子进行冰雹的识别、定位和预报。杨仲江等（2020）采用雷达回波数据训练基于编码器-解码器序列结构的ConvLSTM深度学习模型，对反射率因子的时空变化进行外推，根据闪电发生概率与雷达回波反射率因子之间的相关性对闪电事件进行预警。中国气象局、中国科学院大学和国家气象中心基于数值天气预报数据，合作开发了一种针对强对流天气的深度学习目标预测方案，包括短时强降水、冰雹、对流阵风和雷暴。研究者利用五年的强天气观测结果对美国国家环境预报中心（NationalCentersforEnvironmentalPrediction,NCEP）全球分析资料（FinalOperationalGlobalAnalysis,FNL）进行标注，然后为每种类型的天气选择大量标记样本进行模型训练。该方案以1000-200hPa高度的温度、气压、湿度和风场以及数十种对流物理参数为预测指标，构建并训练了六层卷积神经网络模型，以获取最佳模型权重。在此基础上，将全球预报系统（GlobalForecastSystem,GFS）的预报数据作为输入数据，利用CNN模型对强对流天气进行预测。该方案也比较了CNN模型与其他传统方法的预报性能。实验结果表明，与支持向量机、随机森林等传统机器学习算法相比，深度CNN算法能够自动提取强对流天气的非线性特征，具有更好的预测性能；与预报员主观观测结果相比，深度CNN算法对雷暴、短时强降水、冰雹、对流阵风的TS得分分别提高了16.1%、33.2%、178%、55.7%，预报有明显改善（ZhouKetal.，2019）。——张敬林，薛珂，杨智鹏，张峰，张人禾，杨杰，封国林．人工智能与物联网在大气科学领域中的应用．地球物理学进展.</p><p>郑益勤等(2020) 利用Himawari8卫星图像， 构建了用深度信念网络(DBN )进行强对流云团自动识别的方法， 该方法可以有效识别处于初生到消散不同阶段的强对流云团， 并在一定程度上去除卷云</p><h3 id="雷暴大风"><a href="#雷暴大风" class="headerlink" title="雷暴大风"></a>雷暴大风</h3><p>李海峰（2018）设计并实现了四种雷暴大风识别网络模型。分别是简单卷积神经网络模型、空间上下文循环卷积神经网络模型、时间循环卷积神经网络模型，以及综合两种模型优点的时空循环卷积神经网络模型，设计实验对四种模型进行严格的实验对比。针对雷暴大风识别问题设计的网络模型，结合飑线分割方法，在5000 个雷暴大风测试样本上的识别准确率达到83.2%，相比气象领域的传统方法有明显优势。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在气象领域，Lee等人根据当地雷达信息和降水数据通过径向基神经网络，预测了24小时后的降雨量[6]；</p><p>Robert等在降雨数值分析的基础上，引入了人工神经网络进行局部地区降雨分析[7]；</p><p>Luk等人使用多层前反馈神经网络、偏循环神经网络和时间延迟神经网络3种方法对帕拉玛塔河流域<br>上游暴雨量进行了预测，表明选用这3种模型用来进行分析预测是可行的[8]；</p><p>Chau等将极限学习机与马尔科夫蒙特卡洛方法、Copula和Bat算法结合，实现了巴基斯坦3个农业带的降雨分析，取得了很好的结果[9]；</p><p>韩婷婷、时玮域[10]等人使用SVM方法对大雾天气进行预测，在大雾预测方面实现了新的突破。黄建伟等采用XGBoost集成学习算法，采用多层雷达数据进行降雨分类问题分析搭建了雷达回波与降雨分析系统，并投入日常气象工作中使用。</p><blockquote><p>张敬林，薛珂，杨智鹏，张峰，张人禾，杨杰，封国林．人工智能与物联网在大气科学领域中的应用．地球物理学进展.</p></blockquote><p>机器学习方法如人工神经网络、自组织映射网络分类器、支持向量机分类器和随机森林分类器等成功应用于云识别和分类（张成伟，2019）。作为机器学习中的热点算法，深度学习在图像识别领域取得显著成果，该算法能够从数据中分层次地学习到具备代表性和判别性的语义特征（Chenetal.,2014），利用卷积神经网络、深度信念网络等可以在卫星云图中识别云的类型和判断降水情况等。近年来，深度学习在云识别中引起了广泛关注并且取得一定进展。Xie等（2019）提出了一种新型深度CNN模型SegCloud，用于基于地面观测的精确云图像分割。SegCloud模型具有对称的编码-解码结构，编码器网络将低层云特征图像转化为低分辨率的高层云特征图像，解码器网络将获得的高层云特征图像映射回与输入图像相同的分辨率，最后softmax分类器进行逐像素分类并输出分割结果。研究人员还建立了一个包含400张全天空图像和人工标签的云分割数据库，用于训练SegCloud模型。大量实验结果证明，SegCloud模型能够有效、准确地对地面全天候成像仪获取的全天空图像进行自动云分割，该模型具有强大的云特征识别能力和优越的云特征提取技术，云分割性能明显优于传统方法。AfzaliGorooh等（2020）建立了一个深度神经网络云分类模型DeepCTC（DeepNeuralNetworkCloud-TypeClassification）。该模型根据GOES-16气象卫星上先进基线成像仪（AdvancedBaselineImager,ABI）的高时空和多光谱图像数据进行云分类，使用CloudSat卫星上的云廓线雷达（CloudProfilingRadar,CPR）和GOES-16ABI在美国连续地区（CONtiguousUnitedStates,CONUS）的观测数据进行训练和测试。研究人员对该模型进行了多种模拟实验。飓风哈维事件的ABI模拟图像的结果表明，使用该模型可以实现快速准确的云类型监测；哈维事件的多雷达/多传感器（Multi-Radar/Multi-Sensor,MRMS）降水率数据表明，该模型能够识别深对流云、雨层云等雨云以及估算其降水潜力。此外研究人员还使用该模型评估了卫星遥感降水产品PERSIANN-CCS对不同云类型降水量估算的性能。大量实验表明，DeepCTC模型通过简单、灵活而准确的算法可以快速识别云的类型，对高层云、高积云、积云，雨层云，深对流云和高云等多种云型的分类结果表现良好，对低云的分类效果较差。ZhangX等（2020）提出一种提取对流云的新方法，构建了仅由1×1卷积组成的3ONet深度网络用于提取光谱特征，以及深度对称密集连接全卷积网络SDFCNs用于提取几何特征，使用双流网络将光谱特征和几何特征相结合以提取对流云。实验使用葵花8卫星云图对深度学习框架进行验证，结果表明该方法在对流云提取任务中表现优秀。郑益勤等（2020）基于深度信念网络进行强对流云团自动识别任务的研究，提取葵花8卫星图像的光谱特征和纹理特征，然后参考CloudSat卫星的云分类产品自动构建样本集，利用该样本集进行模型训练，确定参数和结构之后进行云团识别并对识别结果进行后处理。最终结果表明，DBN模型能够有效提高不同阶段强对流云团的识别精度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>气象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>while计算一个人活了几天</title>
    <link href="/2021/11/07/while%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%B4%BB%E4%BA%86%E5%A4%9A%E4%B9%85/"/>
    <url>/2021/11/07/while%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%B4%BB%E4%BA%86%E5%A4%9A%E4%B9%85/</url>
    
    <content type="html"><![CDATA[<h1 id="while-计算一个人活了几天"><a href="#while-计算一个人活了几天" class="headerlink" title="while-计算一个人活了几天"></a>while-计算一个人活了几天</h1><p>主思路：对每一年都进行判断（即需要用到循环，这里用while比较合适），然后一天一天地相加。</p><p>*变量的取名要清晰</p><p>*每个月加完后，初始日为0；每年加完后，初始月为0.</p><p>*c语言中 d=n? 29:28;      一个判断： d=n吗？</p><ol><li>等于，d=29</li><li>不等于，d=28</li></ol><p>这是一个条件表达式，满足条件，执行：前的，不满足，执行后边的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// count用于存放一共活了多少天</span><br>        <span class="hljs-keyword">int</span> year1, year2; <span class="hljs-comment">// year1是你的生日年份，year2是今天的年份</span><br>        <span class="hljs-keyword">int</span> month1, month2;<br>        <span class="hljs-keyword">int</span> day1, day2;<br>        <span class="hljs-keyword">int</span> days[] = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你的生日（如1988-05-20）：&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d-%d&quot;</span>, &amp;year1, &amp;month1, &amp;day1);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入今年日期（如2016-03-28）：&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d-%d&quot;</span>, &amp;year2, &amp;month2, &amp;day2);<br><br>        <span class="hljs-keyword">while</span> (year1 &lt;= year2)<br>        &#123;<br>                days[<span class="hljs-number">1</span>] = (year1 % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (year1 % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year1 % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>)) ? <span class="hljs-number">29</span> : <span class="hljs-number">28</span>;<br> <span class="hljs-comment">///对是否为闰年进行判断，同时对重新赋值。</span><br><br>                <span class="hljs-keyword">while</span> (month1 &lt;= <span class="hljs-number">12</span>)<br>                &#123;<br>                        <span class="hljs-keyword">while</span> (day1 &lt;= days[month1 - <span class="hljs-number">1</span>])<br>                        &#123;<br>                                <span class="hljs-keyword">if</span> (year1 == year2 &amp;&amp; month1 == month2 &amp;&amp; day1 == day2)<br>                                <span class="hljs-comment">//此个if很关键，即在每次年月日判断的终点里不断检查是不是到了今年的日期</span><br>                                &#123;<br>                                        <span class="hljs-keyword">goto</span> FINISH; <span class="hljs-comment">// 跳出多层循环才被迫用goto语句</span><br>                                &#125;<br>                                day1++;<br>                                count++;<br>                        &#125;<br>                        day1 = <span class="hljs-number">0</span>;<br>                        month1++;<br>                &#125;<br>                month1 = <span class="hljs-number">0</span>;<br>                year1++;<br>        &#125;<br><br>FINISH: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你在这个世界上总共生存了%d天\n&quot;</span>, count);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>       2.0版本：可计算如果活到80岁还有几天生命和生命已用百分比。</code></pre><p>在判断的末枝进行两个判断：1、是否到今年；</p><pre><code>                                      2、是否到80岁那年</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">long</span> count1 = <span class="hljs-number">0</span>, count2; <span class="hljs-comment">// count用于存放一共活了多少天</span><br>        <span class="hljs-keyword">int</span> year1, year2, year3; <span class="hljs-comment">// year1是你的生日年份，year2是今天的年份</span><br>        <span class="hljs-keyword">int</span> month1, month2, month3;<br>        <span class="hljs-keyword">int</span> day1, day2, day3;<br>        <span class="hljs-keyword">int</span> days[] = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你的生日（如1988-05-20）：&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d-%d&quot;</span>, &amp;year1, &amp;month1, &amp;day1);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入今天的日期（如2016-03-28）：&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d-%d&quot;</span>, &amp;year2, &amp;month2, &amp;day2);<br><br>        year3 = year1 + <span class="hljs-number">80</span>;<br>        month3 = month1;<br>        day3 = day1;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                days[<span class="hljs-number">1</span>] = (year1 % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (year1 % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year1 % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>)) ? <span class="hljs-number">29</span> : <span class="hljs-number">28</span>;<br>                <span class="hljs-keyword">while</span> (month1 &lt;= <span class="hljs-number">12</span>)<br>                &#123;<br>                        <span class="hljs-keyword">while</span> (day1 &lt;= days[month1 - <span class="hljs-number">1</span>])<br>                        &#123;<br>                                <span class="hljs-keyword">if</span> (year1 == year2 &amp;&amp; month1 == month2 &amp;&amp; day1 == day2)<br>                                &#123;<br>                                        count2 = count1;<br>                                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你在这个世界上总共生存了%d天\n&quot;</span>, count2);<br>                                &#125;<br><br>                                <span class="hljs-keyword">if</span> (year1 == year3 &amp;&amp; month1 == month3 &amp;&amp; day1 == day3)<br>                                &#123;<br>                                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;如果能活到80岁，你还剩下%d天\n&quot;</span>, count1 - count2);<br>                                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你已经使用了%.2f\%的生命，请好好珍惜剩下的时间！\n&quot;</span>, (<span class="hljs-keyword">double</span>)count2 / count1 * <span class="hljs-number">100</span>);<br>                                        <span class="hljs-keyword">goto</span> FINISH;<br>                                &#125;<br><br>                                day1++;<br>                                count1++;<br>                        &#125;<br>                        day1 = <span class="hljs-number">0</span>;<br>                        month1++;<br>                &#125;<br>                month1 = <span class="hljs-number">0</span>;<br>                year1++;<br>        &#125;<br><br>FINISH: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>附：自己写的1.0版本的垃圾代码</p><p>感想：想法没多大问题，分步计算，有点复杂。在每一步进行计算的时候要想好这步干的是什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a,b,c,x,y,z,m,n,num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> j[<span class="hljs-number">12</span>]=&#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br><span class="hljs-keyword">int</span> i[<span class="hljs-number">12</span>]=&#123;<span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你的生日（如1988-05-20）：&quot;</span>);<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d-%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入现在日期（如2016-03-28）：&quot;</span>);<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d-%d&quot;</span>,&amp;x,&amp;y,&amp;z);<br><br><span class="hljs-keyword">if</span> (a%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;a%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>||a%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)<br><br>&#123;<br><br><span class="hljs-keyword">for</span> (m=i[b<span class="hljs-number">-1</span>]-c;b&lt;<span class="hljs-number">12</span>;b++)<br>&#123;<br>m=i[b]+m;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span>(m=c;b&lt;<span class="hljs-number">12</span>;b++)<br>&#123;<br>m=j[b]+m;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (a=a+<span class="hljs-number">1</span>;a&lt;x;a++)<br>&#123;<br><span class="hljs-keyword">if</span> ((a%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;a%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>)||(a%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>))<br>&#123;<br>m=m+<span class="hljs-number">366</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>m=m+<span class="hljs-number">365</span>;<br>&#125;<br>&#125;<br>a=x;<br>b=y;<br>c=z;<br><span class="hljs-keyword">if</span> ((a%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;a%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>)||(a%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">for</span> (n=c;b&gt;=<span class="hljs-number">2</span>;b--)<br>&#123;<br>n=i[b<span class="hljs-number">-2</span>]+n;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span>(n=c;b&gt;=<span class="hljs-number">2</span>;b--)<br>&#123;<br>n=j[b<span class="hljs-number">-2</span>]+n;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你在这个世界上已经生存了%d天&quot;</span>,m+n);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>post:<br>  meta:<br>    author:  # 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值<br>      enable: false<br>    date:  # 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期<br>      enable: true<br>      format: “dddd, MMMM Do YYYY, h:mm a”  # 格式参照 ISO-8601 日期格式化<br>    wordcount:  # 字数统计<br>      enable: true<br>      format: “{} 字”  # 显示的文本，{}是数字的占位符（必须包含)，下同<br>    min2read:  # 阅读时间<br>      enable: true<br>      format: “{} 分钟”<br>    views:  # 阅读次数<br>      enable: false<br>      source: “leancloud”  # 统计数据来源，可选：leancloud | busuanzi   注意不蒜子会间歇抽风<br>      format: “{} 次”</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言，while语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
